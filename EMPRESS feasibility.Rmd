---
title: "EMPRESS feasibility script"
author: "NM"
date: "2026-01-15"
output: html_document
---

To do: sektion 4.1, sektion 4.5, sektion 4.6.2, sektion 4.6.3

## 1.0 Load libraries

```{r include=FALSE}
library(nanoparquet)
library(tidyverse)
library(openxlsx)
library(stringi)
library(janitor)
library(uuid)
```

## 2.0 Load data

```{r include=FALSE}
# -------- Paths to exported data files --------
data_dir <- "C:/Users/nmei0013/Downloads"
f_forms <- file.path(data_dir, "export-export_forms_empress_domain_20260124135216.parquet")
f_events <- file.path(data_dir, "export-export_events_empress_platform_20260123110248.parquet")
allocation <- file.path(data_dir, "export-export_allocations_empress_domain_20260123110315.parquet")

# -------- Load data from parquet files --------
EMPRESS_forms <- read_parquet(f_forms)
EMPRESS_events <- read_parquet(f_events)
EMPRESS_allocation <- read_parquet(allocation)
```

## 3.0 Data preparation

### 3.1 Creation of master DF

#### 3.x Code for safety report including cut off

```{r eval=FALSE, include=FALSE}
#------------------------------------------------------------
# 1) Cutoff date
#------------------------------------------------------------
Safety_trigger_date <- date("2026-02-18")
cuttoff_date <- Safety_trigger_date - days(105) + 1

#------------------------------------------------------------
# 2) Subset of enrolled participants in EMPRESS <= cuttoff_date
#------------------------------------------------------------
EMPRESS_master_safety <- EMPRESS_events %>% 
  filter(
      event_type_name == "enrolment" &
      event_description == "empress_platform" &
      
    # Local datetime for enrolment before cuttoff date
      date(with_tz(timestamp, "Europe/Copenhagen")) <= cuttoff_date 
  ) %>% 
  
  # Rename timestamp to rand_datetime_utc
  rename(
    rand_datetime_utc = timestamp,
         ) %>% 
  
  # Keep only relevant colums
  select(ssid, enrolment_site, rand_datetime_utc)
```

#### 3.1.1 Creation of master dataframe consisting of 200 first enrolled (feasibility)

```{r}
EMPRESS_master_feasibility <- EMPRESS_events %>% 
  # keep only enrolment rows
  filter(str_detect(event_type_name, "enrolment")) %>% 
  
  # order by time to pick the FIRST 200 enrolled participants
  arrange(timestamp) %>% 
  
  # pick first 200 unique ssid
  distinct(ssid, .keep_all = TRUE) %>% 
  slice_head(n = 200) %>% 
  
  # rename timestamp and event_id
  rename(
    rand_datetime_utc = timestamp,
    rand_datetime_id  = event_id
  ) %>% 
  
  # convert UTC to local datetime
  mutate(
    rand_datetime_local = with_tz(rand_datetime_utc, "Europe/Copenhagen")
  ) %>% 
  
  # keep only relevant columns
  select(
    ssid,
    enrolment_site,
    rand_datetime_utc
  )
```

### 3.2 Screening for unwanted values

#### 3.2.1 Python spillover

```{r}
#------------------------------------------------------------
# 1) Scan for Pyhton spill-over
#------------------------------------------------------------
py_obj_summary_forms <- EMPRESS_forms %>% 
  mutate(value_chr = as.character(value)) %>% 
  summarise(
    n_py_object = sum(str_detect(value_chr, "<object\\s"), na.rm = TRUE),
    .by = variable_name
  ) %>% 
  filter(n_py_object > 0) %>% 
  arrange(desc(n_py_object))

#------------------------------------------------------------
# 2) Query-ready table of affected rows
#------------------------------------------------------------
py_obj_rows_forms <- EMPRESS_forms %>%
  mutate(value_chr = as.character(value)) %>%
  filter(str_detect(value_chr, "^<object object at 0x[0-9a-fA-F]+>$")) %>%
  transmute(
    ssid, responsible_site, form_layout, start_datetime, end_datetime,
    variable_name, value = value_chr
  )

#------------------------------------------------------------
# 2) Clean forms data from python spill-over
#------------------------------------------------------------
EMPRESS_forms <- EMPRESS_forms %>%
  mutate(
    value_chr = stringr::str_squish(as.character(value)),
    value_chr = dplyr::if_else(
      stringr::str_detect(value_chr, "^<object object at 0x[0-9a-fA-F]+>$"),
      NA_character_,
      value_chr
    ),
    value = value_chr
  ) %>%
  select(-value_chr)

```

#### 3.2.2 UUID

```{r}
#------------------------------------------------------------
# 3) Scan for UUID
#------------------------------------------------------------
uuid_obj_summary_forms <- EMPRESS_forms %>% 
  mutate(value_chr = str_squish(as.character(value))) %>% 
  summarise(
    n_UUID_object = sum(UUIDvalidate(value_chr), na.rm = TRUE),
    .by = variable_name
  ) %>% 
  filter(n_UUID_object > 0) %>% 
  arrange(desc(n_UUID_object))

#------------------------------------------------------------
# 4) Query-ready table of affected rows
#------------------------------------------------------------
uuid_obj_rows_forms <- EMPRESS_forms %>%
  mutate(value_chr = str_squish(as.character(value))) %>%
  filter(UUIDvalidate(value_chr) == TRUE) %>% 
  transmute(
    ssid, responsible_site, form_layout, start_datetime, end_datetime,
    variable_name, value = value_chr
  )

#------------------------------------------------------------
# 5) Clean forms data from python spill-over
#------------------------------------------------------------
EMPRESS_forms <- EMPRESS_forms %>%
  mutate(
    value_chr = str_squish(as.character(value)),
    value_chr = if_else(
      UUIDvalidate(value_chr) == TRUE, 
      NA_character_,
      value_chr
    ),
    value = value_chr
  ) %>%
  select(-value_chr)

rm(
  py_obj_rows_forms,
  py_obj_summary_forms,
  uuid_obj_rows_forms,
  uuid_obj_summary_forms
)
```

### 3.3 Subsetting relevant variables within forms

#### 3.3.1 Screening variable subset

```{r}
#------------------------------------------------------------
# 1) Preparing screening subset
#------------------------------------------------------------
EMPRESS_forms_screening <- EMPRESS_forms %>% 
  filter( # relevant form_layout and variables
    form_layout == "empress_domain_screening" & 
    variable_name %in% c(
      # Inclusion criteria
      "age_ge_18",
      "sepsis",
      "indication_for_empirical_antibiotics",
      "acutely_critically_ill",
      # Exclusion criteria
      "infection_multiresistent_bacteria",
      "use_of_valproat",
      "pregnant",
      "suspected_cns_infection",
      "allergic_to_betalactam_antibiotics",
      "preceding_iv_antibiotics",
      "co_enrolment_with_empress_not_possible",
      "informed_content_unobtainable",
      "coercive_measures")
  ) %>% 
  select(
    observation_id,
    ssid,
    responsible_site,
    form_layout,
    start_datetime,
    end_datetime,
    variable_name,
    value
  )
```

#### 3.3.2 Baseline variables (and baseline-like screening variables) subet

```{r}
#------------------------------------------------------------
# 1) Preparing baseline subset
#------------------------------------------------------------
EMPRESS_forms_baseline <- EMPRESS_forms %>% 
  filter(ssid %in% EMPRESS_master_feasibility$ssid) %>%  # enrolled participants only
  filter( 
    # baseline-like variables from screening forms
    (form_layout == "empress_domain_screening" & 
    variable_name %in% c(
      "haematological_or_metastatic_cancer",
      "date_of_birth",
      "acute_surgical_admission",
      "use_of_respiratory_support_at_randomisation",
      "use_of_circulatory_support_at_randomisation",
      "rrt_within_72h_before_randomisation")) |
    # baseline variables
    (form_layout == "empress_baseline" &
    variable_name %in% c(
      "ischemic_heart_disease",
      "diabetes",
      "chronic_pulmonary_disease",
      "chronic_liver_disease",
      "immunosuppression",
      "organ_transplantation",
      "chronic_rrt",
      "sex",
      "clinical_frailty_scale",
      "date_of_index_hospital_admission",
      "department_at_which_the_participant_was_included",
      "weight",
      "heigh",
      "systolic_blood_pressure_lowest",
      "primary_site_of_infection",
      "positive_bacterial_culture",
      "type_of_sample",
      "type_of_bacteria",
      "resistance_to_piperacillin_tazobactam",
      "resistance_to_meropenem",
      "use_of_respiratory_support_at_randomisation",
      "type_of_respiratory_support",
      "fio2_before_randomisation",
      "max_oxygen_flow_at_randomisation",
      "treatment_with_antibacterial_agent_prior_to_randomisation",
      "anti_bacterial_agent",
      "use_of_systemic_corticosteroids_at_randomisation",
      "arterial_blood_gas_available",
      "arterial_oxygen_saturation ",
      "pao2",
      "peripheral_oxygen_saturation",
      "lactate_highest",
      "creatinine_highest",
      "limitations_of_care"))
    ) %>%  
    select(
    observation_id,
    ssid,
    responsible_site,
    form_layout,
    start_datetime,
    end_datetime,
    variable_name,
    value
    )
```

#### 3.3.3 Dayform variables subset

```{r}
#------------------------------------------------------------
# 1) Preparing dayform subset
#------------------------------------------------------------
EMPRESS_forms_dayforms <- EMPRESS_forms %>% 
  filter(ssid %in% EMPRESS_master_feasibility$ssid) %>%  # enrolled participants only
  filter( 
    # baseline form layouts from the export
    form_layout %in% c(
      "empress_dayform_1_to_30",
      "empress_dayform_1_to_90",
      "empress_dayform_non_trial_site_1_to_30",
      "empress_dayform_non_trial_site_1_to_90") &
      variable_name %in% c(
        # Dayform 1 - 30 on both trial and non-trial site
        "isolation_due_to_resistant_bacteria",
        "type_of_resistant_bacteria_new",
        "antibiotic_agent_to_which_the_bacteria_was_resistant",
        "invasive_mechanical_ventilation",
        "circulatory_support_min_1h",
        "any_rrt_this_day",
        "anaphylactic_shock_piptazo_meropenem",
        "invasive_fungal_infection",
        "pseudomembranous_colitis",
        "toxic_epidermal_necrolysis",
        
        # Dayform 1 on trial site dayform
        "dosing_regimen",
        
        # Dayform 1 - 30 on trial site
        "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
        "reason_for_not_receiving_at_least_50_percent",
        "use_of_any_another_antibiotic_agent_than_allocated_on_this_day",
        "other_antibiotic_agent_than_allocated_type_treatment",
        "other_antibiotic_agent_than_allocated_type_agent",
        
        # Dayform 31 - 90 on both trial and non-trial site
        "invasive_mechanical_ventilation",
        "circulatory_support_min_1h",
        "any_rrt_this_day"
        )
  ) %>%  
  select(
    observation_id,
    ssid,
    responsible_site,
    form_layout,
    start_datetime,
    end_datetime,
    variable_name,
    value
  )
```

#### 3.3.4 Followup variables subset

```{r}
#------------------------------------------------------------
# 1) Preparing followup 30/90 days subset
#------------------------------------------------------------
EMPRESS_forms_followup <- EMPRESS_forms %>% 
  filter(ssid %in% EMPRESS_master_feasibility$ssid) %>%  # enrolled participants only
  filter(form_layout == "empress_30_90_days_followup" &
         variable_name == "30_90_day_followup") %>% 
  select(
    observation_id,
    ssid,
    responsible_site,
    form_layout,
    start_datetime,
    end_datetime,
    variable_name,
    value)
```

#### 3.3.5 Combining all subsets

```{r}
#------------------------------------------------------------
# 1) Combining the different dataframes for all participants
#------------------------------------------------------------
EMPRESS_forms_all <- bind_rows(
  EMPRESS_forms_screening,
  EMPRESS_forms_baseline, 
  EMPRESS_forms_dayforms,
  EMPRESS_forms_followup
  )
```

#### 3.3.6 Enrolled events

```{r}
#------------------------------------------------------------
# 1) Subset events on enrolled participants
#------------------------------------------------------------
EMPRESS_events_enrol <- EMPRESS_events %>% 
  filter(ssid %in% EMPRESS_master_feasibility$ssid) %>%
  mutate(source = "empress_events")
 
#------------------------------------------------------------
# 2) All events
#    - Creating responsible site for events
#------------------------------------------------------------
events_master_enrol <- EMPRESS_events_enrol %>% 
  mutate(
    responsible_site = case_when(
      event_type_name == "enrolment" ~ str_squish(as.character(enrolment_site)),
      event_type_name == "relocate"  ~ str_to_lower(str_squish(str_extract(as.character(event_description), "^[^/]+"))),
      TRUE ~ NA_character_
    )
  ) %>% 
  group_by(ssid) %>%
  arrange(desc(enrolment_site), timestamp, .by_group = TRUE) %>%
  fill(responsible_site, .direction = "down") %>%
  ungroup() %>% 
  select(-enrolment_site)
```

## 4.0 Data validation

### 4.1 Helper keys

```{r}
# Helper 1: detect missing 
na_blank <- function(x) {
  x <- str_squish(as.character(x))
  x[x %in% c("", "NA", "NaN", "None", "na", "none", "nan")] <- NA_character_
  x
}

# Helper 2: to numeric
to_numeric <- function(x) {

  if (is.numeric(x)) return(x)

  x_chr <- str_to_lower(str_squish(as.character(x)))

  # Explicit missing encodings
  x_chr[x_chr %in% c("", "NA", "NaN", "None", "na", "none", "nan")] <- NA_character_

  # Allow signed numeric values (incl. negatives)
  is_num <- stringr::str_detect(
    x_chr,
    "^[-+]?[0-9]*\\.?[0-9]+$"
  )
  is_num[is.na(is_num)] <- FALSE

  out <- rep(NA_real_, length(x_chr))
  out[is_num] <- as.numeric(x_chr[is_num])

  out
}

# Helper 3
to_bool <- function(x) {
  x <- tolower(trimws(as.character(x)))
  dplyr::case_when(
    x %in% c("true","t","1","yes","y")  ~ TRUE,
    x %in% c("false","f","0","no","n")  ~ FALSE,
    TRUE ~ NA
  )
}
```

### 4.2 General validation

#### 4.2.1 Dayform data range issues

```{r}
# -------------------------------------------------
# 1) Randomisation key 
#    - convert to local time [Make generic]
#    - account for 6 hours offset [Make generic]
# -------------------------------------------------
rand_key <- EMPRESS_master_feasibility %>% 
  transmute(
    ssid = as.character(ssid),
    rand_datetime_utc,
    rand_datetime_local = with_tz(rand_datetime_utc, "Europe/Copenhagen"), 
    rand_day_key_local = date(rand_datetime_local - dhours(6))
  )

# -------------------------------------------------
# 2) Build function: Collapse dayforms 
#    - Create horizon_days (30 / 90)
#    - Expected site type (trial / non_trial)
#            
#    + Collapse dayforms
# -------------------------------------------------

# Build function
collapse_dayforms <- function(df) {

  dayform_layouts <- c(
      "empress_dayform_1_to_30",
      "empress_dayform_1_to_90",
      "empress_dayform_non_trial_site_1_to_30",
      "empress_dayform_non_trial_site_1_to_90"
  )

  df %>%
    filter(form_layout %in% dayform_layouts) %>%
    mutate(
      ssid = as.character(ssid),
      form_layout = as.character(form_layout),
      start_datetime = ymd_hms(start_datetime, tz = "UTC", quiet = TRUE),
      end_datetime   = ymd_hms(end_datetime,   tz = "UTC", quiet = TRUE)
    ) %>%
    filter(!is.na(start_datetime), !is.na(end_datetime)) %>%
    group_by(ssid, form_layout, start_datetime, end_datetime) %>%
    summarise(
      responsible_site = first(as.character(responsible_site)),
      .groups = "drop"
    ) %>%
    mutate(
      horizon_days = case_when(
        str_detect(form_layout, "(^|_)1(_to)?_30$") ~ 29L, # rand_day = first day
        str_detect(form_layout, "(^|_)1(_to)?_90$") ~ 89L, 
        TRUE ~ NA_integer_
      ),
      expected_site_type = case_when(
        form_layout %in% c("empress_dayform_1_to_30",
                           "empress_dayform_1_to_90") ~ "trial",
        form_layout %in% c("empress_dayform_non_trial_site_1_to_30",
                           "empress_dayform_non_trial_site_1_to_90") ~ "non_trial",
        TRUE ~ NA_character_
      )
    )
}

# Collapse dayforms 
dayforms_collapsed <- collapse_dayforms(EMPRESS_forms_all)

# ------------------------------------------------------------
# 3) Build function: Parse relocation destination from event_description
#    + Parse relocate destionations 
# ------------------------------------------------------------
parse_reloc_dest <- function(x) {
  desc <- str_squish(str_to_lower(as.character(x)))

  # keep only the part after "/" if present; otherwise use full string
  suffix <- if_else(str_detect(desc, "/"),
                    str_squish(str_replace(desc, "^.*?/\\s*", "")),
                    desc)

  case_when(
    str_detect(suffix, "^out\\s*of\\s*hospital$") ~ "out_of_hospital",
    str_detect(suffix, "^non\\s*[-]?\\s*trial\\s*site$") ~ "non_trial",
    str_detect(suffix, "^trial\\s*site$") ~ "trial",
    TRUE ~ NA_character_
  )
}

# Parse relocation destinations 
events_with_relocation_dest <- events_master_enrol %>% 
  mutate(
    reloc_dest = if_else(event_type_name == "relocate", 
                         parse_reloc_dest(event_description), 
                         NA_character_),
    timestamp = ymd_hms(timestamp, tz = "UTC", quiet = TRUE)
  )

# ------------------------------------------------------------
# 4) Function: build state intervals  per ssid (trial/nontrial/out_of_hospital),   #    anchored at randomisation
#    + Create state intervals  
# ------------------------------------------------------------
build_state_intervals <- function(events_df, rand_df) {
# - initial state: trial from rand_time to next relocate/death/horizon (trunc later)
# - each relocate starts a new state at its timestamp 
# - end at next relocate timestamp; death will be applied as censor later

  # death times
  death <- events_df %>%
    filter(event_type_name == "death") %>%
    summarise(
      death_time = suppressWarnings(min(timestamp, na.rm = TRUE)),
      .by = ssid
    )

  reloc <- events_df %>%
    filter(event_type_name == "relocate") %>%
    filter(!is.na(reloc_dest)) %>%
    arrange(ssid, timestamp) %>%
    select(ssid, event_id, timestamp, reloc_dest, event_description)

  # Create per-ssid event stream starting at randomisation with implicit "trial"
  base <- rand_df %>%
    transmute(
      ssid = as.character(ssid),
      rand_time = ymd_hms(rand_datetime_utc, tz = "UTC", quiet = TRUE)
    ) %>%
    filter(!is.na(rand_time))

  # Build intervals:
  # - initial state: trial from rand_time to next relocate/death/horizon (trunc later)
  # - each relocate starts a new state at its timestamp
  # - end at next relocate timestamp; death will be applied as censor later
  state_points <- bind_rows(
    base %>% transmute(ssid, point_time = rand_time, state = "trial", source = "rand", event_id = NA_character_),
    reloc %>% transmute(ssid, point_time = timestamp, state = reloc_dest, source = "relocate", event_id = as.character(event_id))
  ) %>%
    arrange(ssid, point_time)

  intervals <- state_points %>%
    group_by(ssid) %>%
    mutate(
      interval_start = point_time,
      interval_end = lead(point_time),
      interval_state = state,
      interval_event_id = event_id,
      interval_source = source
    ) %>%
    ungroup() %>%
    select(ssid, interval_start, interval_end, interval_state, interval_event_id, interval_source)

  # If interval_end is NA (last known state), keep open-ended; will be truncated by horizon/death later
  intervals %>%
    left_join(death, by = "ssid") %>%
    left_join(base %>% select(ssid, rand_time), by = "ssid")
}

state_intervals <- build_state_intervals(events_with_relocation_dest, rand_key) %>%
  left_join(
    rand_key %>% 
      select(
        ssid,
        rand_day_key_local
      ),
    by = "ssid"
      )

# ------------------------------------------------------------
# 5) Derive admitted intervals per horizon (30/90) AND site type
# ------------------------------------------------------------
make_admitted_intervals <- function(state_int, horizon_days) {

  state_int %>%
    mutate(
      last_day_key_local = rand_day_key_local + days(horizon_days),

      # Explicit local timestamp at 05:59:59
      horizon_end_local = ymd_hms(
        paste0(last_day_key_local + days(1), " 05:59:59"),
        tz = "Europe/Copenhagen",
        quiet = TRUE
      ),
      horizon_end = with_tz(horizon_end_local, "UTC"),

      raw_end    = coalesce(interval_end, horizon_end),
      cens_end_h = pmin(raw_end, horizon_end, na.rm = TRUE),
      cens_end   = if_else(!is.na(death_time),
                           pmin(cens_end_h, death_time, na.rm = TRUE),
                           cens_end_h),

      admitted = interval_state %in% c("trial", "non_trial"),

      ended_by = case_when(
        !is.na(death_time)    & cens_end == death_time   ~ "death",
        !is.na(interval_end)  & cens_end == interval_end ~ "relocate",
        cens_end == horizon_end                           ~ "horizon",
        TRUE                                             ~ "other"
      )
    ) %>%
    filter(admitted) %>%
    mutate(
      adm_start = pmax(interval_start, rand_time, na.rm = TRUE),
      adm_end   = cens_end
    ) %>%
    filter(!is.na(adm_start), !is.na(adm_end), adm_end > adm_start) %>%
    transmute(
      ssid,
      horizon_days = horizon_days,
      site_type = interval_state,
      adm_start,
      adm_end,
      ended_by,
      horizon_end
    )
}

admitted_30 <- make_admitted_intervals(state_intervals, 29)
admitted_90 <- make_admitted_intervals(state_intervals, 89)
admitted_all <- bind_rows(admitted_30, admitted_90)

# ------------------------------------------------------------
# 5) Check each collapsed dayform is fully contained in an admitted interval
# ------------------------------------------------------------

is_contained_in_any_interval <- function(start, end, int_start, int_end) {
  any(start >= int_start & end <= (int_end + seconds(1))) 
}

dayform_admission_check <- dayforms_collapsed %>%
  left_join(rand_key %>% transmute(
    ssid,
    rand_time = ymd_hms(rand_datetime_utc, tz = "UTC", quiet = TRUE)),
            by = "ssid") %>%
  # attach relevant admitted intervals as list-column
  left_join(
    admitted_all %>%
      group_by(ssid, horizon_days, site_type) %>%
      summarise(intervals = list(pick(everything())), .groups = "drop"),
    by = c("ssid" = "ssid",
           "horizon_days" = "horizon_days",
           "expected_site_type" = "site_type")
  ) %>%
  mutate(
    has_interval_info = !map_lgl(intervals, is.null),
    within_admitted_period = pmap_lgl(
      list(start_datetime, end_datetime, intervals),
      function(st, en, ints) {
        if (is.null(ints) || nrow(ints) == 0) return(FALSE)
        is_contained_in_any_interval(st, en, ints$adm_start, ints$adm_end)
      }
    ),
    issue = case_when(
      !has_interval_info ~ "no_admitted_intervals_for_expected_site_type",
      !within_admitted_period ~ "dayform_outside_admitted_period",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(issue)) %>%
  transmute(
    ssid,
    form_layout,
    expected_site_type,
    horizon_days,
    start_datetime,
    end_datetime,
    responsible_site,
    issue
  ) %>%
  arrange(ssid, start_datetime)

# ==================================================
# DEBUG: Dayforms occurring outside admitted intervals
# --------------------------------------------------
# What this section does:
#   1) Attach admitted intervals (adm_start / adm_end) as a list-column
#      to each collapsed dayform record
#   2) Evaluate interval containment using a row-wise pmap check
#   3) Keep only problematic dayforms (outside all admitted intervals)
#   4) Convert timestamps to local time for human-readable inspection
#   5) Extract one example case (ssid + horizon + site type) for deep dive
# ==================================================
# Re-create a debug table keeping the admission intervals as a list-column
debug_tbl <- dayforms_collapsed %>%
  left_join(
    admitted_all %>%
      # Group admitted intervals per patient, horizon, and site type
      group_by(ssid, horizon_days, site_type) %>%
      summarise(
        intervals = list(dplyr::pick(everything())),
        .groups = "drop"
      ),
    by = c(
      "ssid" = "ssid",
      "horizon_days" = "horizon_days",
      "expected_site_type" = "site_type"
    )
  ) %>%
  mutate(
    # Check whether the dayform interval is fully contained
    # within ANY admitted interval
    within = purrr::pmap_lgl(
      list(start_datetime, end_datetime, intervals),
      function(st, en, ints) {
        if (is.null(ints) || nrow(ints) == 0) return(FALSE)
        any(st >= ints$adm_start & en <= ints$adm_end)
      }
    )
  ) %>%
  # Keep only dayforms outside admitted periods
  filter(!within) %>%
  # Convert to local time for easier manual inspection
  mutate(
    start_local = with_tz(start_datetime, "Europe/Copenhagen"),
    end_local   = with_tz(end_datetime, "Europe/Copenhagen")
  )

debug_tbl

# --------------------------------------------------
# Inspect a single problematic case in detail
# --------------------------------------------------
problem_ssid <- debug_tbl$ssid[1]
problem_h    <- debug_tbl$horizon_days[1]
problem_type <- debug_tbl$expected_site_type[1]

admitted_all %>%
  filter(
    ssid == problem_ssid,
    horizon_days == problem_h,
    site_type == problem_type
  ) %>%
  mutate(
    adm_start_local = with_tz(adm_start, "Europe/Copenhagen"),
    adm_end_local   = with_tz(adm_end, "Europe/Copenhagen")
  ) %>%
  arrange(adm_start) %>%
  select(
    ssid,
    horizon_days,
    site_type,
    adm_start_local,
    adm_end_local,
    ended_by,
    interval_end = adm_end,
    horizon_end
  )
```

#### 4.2.2 Overlapping trial and non-trial dayforms

Check for overlapping trial- and non-trial dayforms. None expected.

```{r}
# -------------------------------------------------
# 1) Function: Overlaps detection + counts (n overlaps per ssid)
# -------------------------------------------------
count_overlaps <- function(trial_df, nontrial_df, inclusive = TRUE) {

  overlaps <- trial_df %>%
    inner_join(nontrial_df, by = "ssid", relationship = "many-to-many",
               suffix = c("_trial", "_nontrial")) %>%
    mutate(
      is_overlap = if (inclusive) {
        (start_datetime_trial <= end_datetime_nontrial) &
          (start_datetime_nontrial <= end_datetime_trial)
      } else {
        (start_datetime_trial <  end_datetime_nontrial) &
          (start_datetime_nontrial <  end_datetime_trial)
      },
      overlap_start = pmax(start_datetime_trial, start_datetime_nontrial),
      overlap_end   = pmin(end_datetime_trial,   end_datetime_nontrial)
    ) %>%
    filter(is_overlap)

  # A) Pairwise table (audit)
  overlap_pairs <- overlaps %>%
    transmute(
      ssid,
      trial_start = start_datetime_trial,
      trial_end   = end_datetime_trial,
      nontrial_start = start_datetime_nontrial,
      nontrial_end   = end_datetime_nontrial,
      overlap_start, 
      overlap_end
    ) %>%
    arrange(ssid, overlap_start)

  # B) Counts per ssid (validation signal)
  overlap_counts <- overlap_pairs %>%
    summarise(
      n_overlapping_pairs = n(),
      .by = ssid
    ) %>%
    arrange(desc(n_overlapping_pairs))

  list(
    overlap_pairs = overlap_pairs, 
    overlap_counts = overlap_counts
       )
}

# -------------------------------------------------
# 2) Run overlap checks on 1–90 and 1–30 dayforms
#    and extract results into explicit data frames
# -------------------------------------------------
# Collapse all four dayform layouts once
dayforms_collapsed <- collapse_dayforms(EMPRESS_forms_all)

# Subset for each comparison
trial_1_90 <- dayforms_collapsed %>% 
  filter(form_layout == "empress_dayform_1_to_90")

nontrial_1_90 <- dayforms_collapsed %>% 
  filter(form_layout == "empress_dayform_non_trial_site_1_to_90")

trial_1_30 <- dayforms_collapsed %>% 
  filter(form_layout == "empress_dayform_1_to_30")

nontrial_1_30 <- dayforms_collapsed %>% 
  filter(form_layout == "empress_dayform_non_trial_site_1_to_30")

# Run overlap checks
res_1_90 <- count_overlaps(trial_1_90, nontrial_1_90, inclusive = TRUE)
res_1_30 <- count_overlaps(trial_1_30, nontrial_1_30, inclusive = TRUE)

# -------------------------------------------------
# 3) Extract outputs into explicit data frames
# -------------------------------------------------
# 1–90 dayforms
df_overlap_counts_1_90 <- res_1_90$overlap_counts %>%
  mutate(window = "1_to_90")

df_overlap_pairs_1_90 <- res_1_90$overlap_pairs %>%
  mutate(window = "1_to_90")

# 1–30 dayforms
df_overlap_counts_1_30 <- res_1_30$overlap_counts %>%
  mutate(window = "1_to_30")

df_overlap_pairs_1_30 <- res_1_30$overlap_pairs %>%
  mutate(window = "1_to_30")

# -------------------------------------------------
# 4) Combine results across windows (optional)
# -------------------------------------------------

overlap_counts_all <- bind_rows(
  df_overlap_counts_1_90,
  df_overlap_counts_1_30
)

overlap_pairs_all <- bind_rows(
  df_overlap_pairs_1_90,
  df_overlap_pairs_1_30
)

# -------------------------------------------------
# 5) Cleanup intermediate objects
# -------------------------------------------------

rm(
  trial_1_90,
  nontrial_1_90,
  trial_1_30,
  nontrial_1_30,
  res_1_90,
  res_1_30
)
```

### 4.3 Outliers

#### 4.3.1 Outliers by hard/soft boundries

```{r}
# -------------------------------------------------
# 1) Define validation rules for baseline and baseline-like variables
# -------------------------------------------------
# Hard bounds = impossible/outside absolute physiological or data constraints
# Soft bounds = clinically implausible (flag for review), but possible

# Define hard/soft boundaries (match easyRF, except highest lactate)
rules <- tibble::tribble(
  ~variable, ~hard_lo, ~hard_hi, ~soft_lo, ~soft_hi, ~unit,
  "weight",  20,  500,  22,  150, "kg",
  "height", 120,  240, 150,  200, "cm",
  "systolic_blood_pressure_lowest",  30,  300,  60,  240, "mmHg",
  "fio2_before_randomisation",        0,    1, 0.21,   1, "fraction",
  "max_oxygen_flow_at_randomisation", 0,  100,   0,  60, "L/min",
  "arterial_oxygen_saturation",       0,  100,  70, 100, "%",
  "peripheral_oxygen_saturation",     0,  100,  70, 100, "%",
  "pao2",                              0,   40,   4,  20, "kPa",
  "lactate_highest",                   0,   30, 0.5,  20, "mmol/L",
  "creatinine_highest",                0, 2000,  30, 1500, "µmol/L")

# -------------------------------------------------
# 2) Restrict to variables to those present in rules and 
#    - create raw value for reporting (preserves original)
#    - create numeric value with missing detected 
#    - filter on non-missing values
# -------------------------------------------------
EMPRESS_forms_numeric <- EMPRESS_forms_all %>% 
  filter(variable_name %in% rules$variable) %>% 
  mutate(
    value_raw = as.character(value),
    value_num = to_numeric(value_raw)) %>% 
  filter(!is.na(value_num))

# -------------------------------------------------
# 3) Join validation rules and apply rules 
# -------------------------------------------------
EMPRESS_forms_numeric_validation <- EMPRESS_forms_numeric %>% 
  inner_join(
    rules,
    by = c("variable_name" = "variable")
  ) %>% mutate(
    issue_type = case_when(
      value_num < hard_lo | value_num > hard_hi ~ "hard_outlier",
      value_num < soft_lo | value_num > soft_hi ~ "soft_outlier",
      TRUE ~ "ok"
    ),
    source = form_layout
  ) 

# -------------------------------------------------
# 4) Validation report
#    - Change datetimes to local time [Make generic at some point]
# -------------------------------------------------
validation_outliers_boundaries <- EMPRESS_forms_numeric_validation %>% 
  filter(issue_type %in% c("hard_outlier", "soft_outlier")) %>% 
  transmute(
    id = observation_id,
    ssid,
    responsible_site,
    source,
    time_point = paste0(with_tz(start_datetime, "Europe/Copenhagen"),
                        " - ",
                        with_tz(start_datetime, "Europe/Copenhagen")
                        ),
    variable_name,
    value = value_raw,
    issue_type,
    note = 
      case_when(
      issue_type == "hard_outlier" 
      ~ paste0("Outside hard bounds [", hard_lo, ", ", hard_hi, "] ", unit),
      issue_type == "soft_outlier" 
      ~ paste0("Outside soft bounds [", soft_lo, ", ", soft_hi, "] ", unit),
      TRUE ~ NA_character_
      )
    )
```

#### 4.3.2 Outliers by distribution

```{r}
# -------------------------------------------------
# 1) Calculate 1%/99% bounds per variable [Change as needed]
# -------------------------------------------------
pct_bounds <- EMPRESS_forms_numeric %>% 
  group_by(variable_name) %>% 
  summarise(
    p01 = quantile(value_num, 0.01, na.rm = TRUE),
    p99 = quantile(value_num, 0.99, na.rm = TRUE),
    .groups = "drop"
    )

# -------------------------------------------------
# 2) Join and flag outliers 
# -------------------------------------------------
validation_outliers_pct <- EMPRESS_forms_numeric %>% 
  left_join(pct_bounds, by = "variable_name") %>% 
  mutate(
    issue_type = case_when(
      value_num < p01 ~ "low_extreme_1pct",
      value_num > p99 ~ "high_extreme_99pct",
      TRUE ~ NA_character_
    ),
    source = form_layout
  ) %>% 
  filter(!is.na(issue_type))

# -------------------------------------------------
# 3) Validation report
#    - Change datetimes to local time [Make generic at some point]
# -------------------------------------------------
validation_outliers_pct <- validation_outliers_pct %>% 
  transmute(
    id = observation_id, 
    ssid,
    responsible_site,
    source,
    time_point = paste0(with_tz(start_datetime, "Europe/Copenhagen"),
                        " - ",
                        with_tz(start_datetime, "Europe/Copenhagen")
                        ),
    variable_name,
    value = value_raw,
    issue_type,
    note = case_when(
      issue_type == "low_extreme_1pct" ~ "extreme value, below 1% of observations",
      issue_type == "high_extreme_99pct" ~ "extreme value, above 99% of observations",
      TRUE ~ NA_character_
    )
  )

# -------------------------------------------------
# 4) Cleanup
# -------------------------------------------------
rm(
  EMPRESS_forms_numeric,
  EMPRESS_forms_numeric_validation,
  pct_bounds,
  rules
)
```

### 4.4 Missing

```{r}
# -------------------------------------------------
# 1) Validation report for missing
# -------------------------------------------------
validation_missing_values <- EMPRESS_forms_all %>%
  
  # Standardise missing  
  # [As of now, actual confirmed missing (unkowns) and blanks are treated as missing - change if needed. Empty fields in export == not filled]
  
  mutate(
    value_raw = as.character(value),
    value_std = na_blank(value_raw),
    source = form_layout
  ) %>% 
  
  # Validation report
  # - Change datetimes to local time [Make generic at some point]
  filter(is.na(value_std) | value_std == "Unknown") %>% # [Change if needed]
  transmute(
    id = observation_id,
    ssid,
    responsible_site,
    source,
    time_point = paste0(with_tz(start_datetime, "Europe/Copenhagen"),
                        " - ",
                        with_tz(start_datetime, "Europe/Copenhagen")
                        ),
    variable_name,
    value = value_raw,
    issue_type = "missing_value",
    note = "Values missing / not filled in"
  ) 
```

### 4.5 Date issues

```{r}
# -------------------------------------------------
# 1) Build small anchor table in wide format with observation ids
# -------------------------------------------------
# Get form dates
form_date_vars <- c(
  "date_of_birth",
  "date_of_index_hospital_admission"
)

anchors_date_long <- EMPRESS_forms_all %>%
  filter(variable_name %in% form_date_vars) %>%
  transmute(
    id = observation_id,
    ssid,
    responsible_site,
    source = form_layout,
    start_datetime,
    end_datetime,
    variable_name,
    value_date = ymd(na_if(trimws(as.character(value)), ""))
  )

anchors_date_wide <- anchors_date_long %>%
  select(ssid, responsible_site, variable_name, value_date) %>%
  pivot_wider(
    id_cols = c(ssid, responsible_site),
    names_from = variable_name,
    values_from = value_date
  ) %>%
  left_join(
    anchors_date_long %>%
      mutate(var_id = paste0(variable_name, "__id")) %>%
      select(ssid, responsible_site, var_id, id) %>%
      pivot_wider(
        id_cols = c(ssid, responsible_site),
        names_from = var_id,
        values_from = id
      ),
    by = c("ssid", "responsible_site")
  )

# Add randomisation time from master (convert to local time)
anchors <- EMPRESS_master_feasibility %>%
  transmute(
    ssid,
    responsible_site = enrolment_site,
    rand_time_local = with_tz(rand_datetime_utc, "Europe/Copenhagen"),
    rand_date = date(rand_time_local)
  ) %>%
  left_join(anchors_date_wide, by = c("ssid", "responsible_site"))

# -------------------------------------------------
# 2) Build canonical event log (EMPRESS) in long format
# -------------------------------------------------
empress_keep <- c(
  "death",
  "withdrawn_consent_empress",
  "clinical_decision_empress",
  "discontinuation_therapy",
  "involuntary_hospitalisation",
  "sar_susar",
  "susar",
  "consent_from_trial_guardian",
  "consent_from_relative",
  "consent_from_participant",
  "consent_obtained",
  "relocate")

events <- events_master_enrol %>%
  filter(event_type_name %in% empress_keep) %>%
  mutate(
    event_time_local = with_tz(timestamp, "Europe/Copenhagen"),
    id = event_id
  ) %>%
  select(id, ssid, source, responsible_site, event_type_name, event_time_local)

# -------------------------------------------------
# 3) Define event groups
# -------------------------------------------------
eop_susar_events <- c(
  "death",
  "withdrawn_consent",
  "clinical_decision",
  "discontinuation_therapy",
  "involuntary_hospitalisation",
  "sar_susar",
  "susar"
)

relocate_events <- "relocate"

consent_events <- c(
  "consent_from_trial_guardian",
  "consent_from_relative",
  "consent_from_participant",
  "consent_obtained"
)

# -------------------------------------------------
# 4) Validation (set-based)
# -------------------------------------------------
events_with_anchor <- events %>%
  left_join(
    anchors %>% select(ssid, rand_time_local),
    by = "ssid"
  )

# 1) HARD: events before randomisation
issues_before_rand <- events_with_anchor %>%
  filter(!is.na(event_time_local), !is.na(rand_time_local)) %>%
  filter(event_time_local < rand_time_local) %>%
  transmute(
    id,
    ssid,
    responsible_site,
    source,
    time_point = as.character(event_time_local),
    variable = event_type_name,
    value = as.character(event_time_local),
    issue_type = "hard",
    note = paste0(
      "Event time (", event_time_local,
      ") is before randomisation (", rand_time_local, ")"
    )
  )

# 2) HARD: events > 90 days after randomisation
issues_after_90 <- events_with_anchor %>%
  filter(!is.na(event_time_local), !is.na(rand_time_local)) %>%
  filter(event_time_local > rand_time_local + days(90)) %>%
  transmute(
    id,
    ssid,
    responsible_site,
    source,
    time_point = as.character(event_time_local),
    variable = event_type_name,
    value = as.character(event_time_local),
    issue_type = "hard",
    note = paste0(
      "Event time (", event_time_local,
      ") is > 90 days after randomisation (", rand_time_local, ")"
    )
  )

# 3) HARD: events after death
death_time <- events %>%
  filter(event_type_name == "death") %>%
  group_by(ssid) %>%
  summarise(
    death_time = min(event_time_local, na.rm = TRUE),
    .groups = "drop"
  )

issues_after_death <- events %>%
  filter(
    (event_type_name %in% eop_susar_events & event_type_name != "death") |
      event_type_name == "consent_from_participant"
  ) %>%
  left_join(death_time, by = "ssid") %>%
  filter(!is.na(event_time_local), !is.na(death_time)) %>%
  filter(event_time_local > death_time) %>%
  transmute(
    id,
    ssid,
    responsible_site,
    source,
    time_point = as.character(event_time_local),
    variable = event_type_name,
    value = as.character(event_time_local),
    issue_type = "hard",
    note = paste0(
      "Event time (", event_time_local,
      ") is after death time (", death_time, ")"
    )
  )

# -------------------------------------------------
# 5) Baseline validation
# -------------------------------------------------
issues_baseline <- anchors %>%
  rowwise() %>%
  transmute(
    ssid,
    responsible_site,
    issues = list({
      out <- tibble(
        variable = character(),
        issue_type = character(),
        value = character(),
        note = character(),
        id = character()
      )

      add_issue <- function(out, variable, issue_type, value, note, id = NA_character_) {
        bind_rows(
          out,
          tibble(
            variable = variable,
            issue_type = issue_type,
            value = as.character(value),
            note = note,
            id = as.character(id)
          )
        )
      }

      dob <- date_of_birth
      hosp <- date_of_index_hospital_admission
      rdt <- rand_date

      dob_id <- date_of_birth__id
      hosp_id <- date_of_index_hospital_admission__id

      if (!is.na(dob) && dob > Sys.Date()) {
        out <- add_issue(out, "date_of_birth", "hard", dob, "Date of birth is in the future", dob_id)
      }

      if (!is.na(dob) && !is.na(rdt) && dob > rdt) {
        out <- add_issue(
          out, "date_of_birth", "hard", dob,
          paste0("Date of birth (", dob, ") is after randomisation date (", rdt, ")"),
          dob_id
        )
      }

      if (!is.na(dob) && !is.na(rdt) && dob <= rdt && interval(dob, rdt) < years(18)) {
        out <- add_issue(
          out, "date_of_birth", "hard", dob,
          paste0("Age < 18 at randomisation date (", rdt, ")"),
          dob_id
        )
      }

      if (!is.na(hosp) && !is.na(dob) && hosp < dob) {
        out <- add_issue(
          out, "date_of_index_hospital_admission", "hard", hosp,
          paste0("Index hospital admission (", hosp, ") is before date of birth (", dob, ")"),
          hosp_id
        )
      }

      if (!is.na(hosp) && !is.na(rdt) && hosp > rdt) {
        out <- add_issue(
          out, "date_of_index_hospital_admission", "hard", hosp,
          paste0("Index hospital admission (", hosp, ") is after randomisation date (", rdt, ")"),
          hosp_id
        )
      }

      if (!is.na(hosp) && !is.na(rdt) && interval(hosp, rdt) > years(1)) {
        out <- add_issue(
          out, "date_of_index_hospital_admission", "soft", hosp,
          paste0("Index hospital admission (", hosp, ") is > 1 year before randomisation (", rdt, ")"),
          hosp_id
        )
      }

      out
    })
  ) %>%
  ungroup() %>%
  unnest(issues) %>%
  filter(!is.na(variable)) %>%
  left_join(
    EMPRESS_forms_all %>%
      transmute(
        id = observation_id,
        source = form_layout,
        time_point = as.character(
          paste0(
            with_tz(start_datetime, "Europe/Copenhagen"),
            " - ",
            with_tz(end_datetime, "Europe/Copenhagen")
          )
        )
      ),
    by = "id"
  ) %>%
  relocate(id, ssid, responsible_site, source, time_point, variable, value, issue_type, note)

# -------------------------------------------------
# 6) Validation report
# -------------------------------------------------

validation_dates <- bind_rows(
  issues_baseline,
  issues_before_rand,
  issues_after_90,
  issues_after_death
)

# -------------------------------------------------
# 7) Cleanup
# -------------------------------------------------

rm(
  anchors,
  anchors_date_long,
  anchors_date_wide,
  issues_baseline,
  death_time,
  events,
  events_with_anchor,
  issues_after_90,
  issues_after_death,
  issues_before_rand,
  consent_events,
  empress_keep,
  form_date_vars,
  eop_susar_events
)
```

### 4.6 Logical issues

#### 4.6.1 Screening / baseline / dayform logic issues

```{r}
# -------------------------------------------------
# 1) Build anchor with relevant baseline / screening vars 
# -------------------------------------------------

# Get relevant vars
screening_vars <- c(
  "use_of_circulatory_support_at_randomisation",
  "use_of_respiratory_support_at_randomisation",
  "rrt_within_72h_before_randomisation",
  "acutely_critically_ill"
)

baseline_vars <- c(
  "chronic_rrt",
  "use_of_respiratory_support_at_randomisation",
  "type_of_respiratory_support"   # <-- ADD THIS
)

# Build screening and baseline anchor
anchor_screening <- EMPRESS_forms_all %>%
  filter(ssid %in% EMPRESS_master_feasibility$ssid) %>%  # enrolled participants only
  filter(
    form_layout == "empress_domain_screening",
    variable_name %in% screening_vars
  )

anchor_baseline <- EMPRESS_forms_all %>% 
  filter(
    form_layout == "empress_baseline",
    variable_name %in% baseline_vars
  )

# -------------------------------------------------
# 2) Combine anchors while preserving data provenance
# -------------------------------------------------

anchor <- bind_rows(anchor_screening, anchor_baseline) %>%
  mutate(
    ssid = as.character(ssid),
    enrolment_site = as.character(responsible_site),
    observation_id = as.character(observation_id),
    source = case_when(
      form_layout == "empress_domain_screening" ~ "screening",
      form_layout == "empress_baseline"         ~ "baseline",
      TRUE ~ NA_character_
    ),
    colname = paste0(source, "__", variable_name)
  )

# Wide values
anchor_wide_vals <- anchor %>%
  select(ssid, enrolment_site, colname, value) %>%
  pivot_wider(
    id_cols = c(ssid, enrolment_site),
    names_from = colname,
    values_from = value,
    values_fill = NA_character_
  )

# Wide observation IDs (suffix columns)
anchor_wide_ids <- anchor %>%
  mutate(colname_id = paste0(colname, "__observation_id")) %>%
  select(ssid, enrolment_site, colname_id, observation_id) %>%
  pivot_wider(
    id_cols = c(ssid, enrolment_site),
    names_from = colname_id,
    values_from = observation_id,
    values_fill = NA_character_
  )

# Combine
anchor_wide <- anchor_wide_vals %>%
  left_join(anchor_wide_ids, by = c("ssid", "enrolment_site")) %>%
  mutate(
    across(
      matches("^(screening__|baseline__)") & !ends_with("__observation_id"),
      ~ dplyr::case_when(
        .x == "Yes" ~ "TRUE",
        .x == "No"  ~ "FALSE",
        TRUE        ~ .x
      )
    )
  )
```

#### 4.6.2 Critically illness validation

```{r}
# -------------------------------------------------
# Rule 1) Critically ill, but is not recieving either respiratory or circulatory support
# -------------------------------------------------
issue_critically_illness <- anchor_wide %>%
  mutate(
    # If acutely_critically_ill is TRUE, at least one of resp/circ must be TRUE
    rule_violation =
      screening__acutely_critically_ill %in% TRUE &
      !(screening__use_of_respiratory_support_at_randomisation %in% TRUE |
          screening__use_of_circulatory_support_at_randomisation %in% TRUE)
  ) %>%
  filter(rule_violation) %>%
  transmute(
    ssid,
    responsible_site = enrolment_site,

    # keep the obs ids (still useful for drilling down)
    id_1 = screening__acutely_critically_ill__observation_id,
    id_2 = screening__use_of_respiratory_support_at_randomisation__observation_id,
    id_3 = screening__use_of_circulatory_support_at_randomisation__observation_id,

    variable_name = "critically_illness_requires_support",
    issue_type = "hard",
    note = paste0(
      "Acutely critically ill is TRUE but both supports are FALSE/NA: ",
      "acutely_critically_ill=", screening__acutely_critically_ill,
      ", respiratory_support=", screening__use_of_respiratory_support_at_randomisation,
      ", circulatory_support=", screening__use_of_circulatory_support_at_randomisation,
      ". At least one support must be TRUE."
    )
  )

# Join with anchor to long format report: 
validation_critically_illness <- issue_critically_illness %>% 
  transmute(
    ssid,
    id = id_1,  # join on the primary observation id (acutely_critically_ill)
    responsible_site,
    variable_name,
    issue_type,
    note
  ) %>% 
  left_join(
    anchor %>% 
      transmute(
        ssid, 
        responsible_site_anchor = responsible_site,
        source = form_layout,
        id = as.character(observation_id),
        time_point = as.character(lubridate::interval(
          lubridate::with_tz(start_datetime, "Europe/Copenhagen"),
          lubridate::with_tz(end_datetime, "Europe/Copenhagen")
        )),
        value
      ),
    by = c("ssid", "id")
  ) %>% 
  # Prefer the site from the anchor row if available
  mutate(
    responsible_site = coalesce(responsible_site_anchor, responsible_site)
  ) %>% 
  select(-responsible_site_anchor) %>% 
  relocate(
    id, ssid, responsible_site, source, time_point, variable_name, value, issue_type, note
  )
```

#### 4.6.3 Respiratory support logic check

```{r}
# -------------------------------------------------
# 1) Build first trial day (empress_dayform_1_to_90) with observation ids
# -------------------------------------------------
day_vars <- c(
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h"
)

# First trial dayform (1_to_90) - long format, keep FIRST day per ssid
first_dayform_1_to_90_long <- EMPRESS_forms_all %>% 
  filter(
    form_layout == "empress_dayform_1_to_90",
    variable_name %in% day_vars
  ) %>% 
  mutate(
    ssid = as.character(ssid),
    value_bool = to_bool(value)
  ) %>% 
  arrange(ssid, start_datetime) %>% 
  group_by(ssid) %>% 
  filter(start_datetime == first(start_datetime)) %>% 
  ungroup()

# Pivot values wide (logical)
first_dayform_vals <- first_dayform_1_to_90_long %>% 
  select(ssid, responsible_site, start_datetime, end_datetime, variable_name, value_bool) %>% 
  pivot_wider(
    id_cols = c(ssid, responsible_site, start_datetime, end_datetime),
    names_from = variable_name,
    values_from = value_bool
  )

# Pivot observation ids wide
first_dayform_ids <- first_dayform_1_to_90_long %>%
  mutate(var_id = paste0(variable_name, "__observation_id")) %>%
  select(ssid, responsible_site, start_datetime, end_datetime, var_id, observation_id) %>%
  pivot_wider(
    id_cols = c(ssid, responsible_site, start_datetime, end_datetime),
    names_from = var_id,
    values_from = observation_id
  )

# Merge and standardise names robustly
first_trial_dayform_1_to_90_wide <- first_dayform_vals %>% 
  left_join(
    first_dayform_ids,
    by = c("ssid", "responsible_site", "start_datetime", "end_datetime")
  ) %>% 
  rename(
    first_instance_mv       = any_of("invasive_mechanical_ventilation"),
    first_instance_mv_obsid = any_of(c(
      "invasive_mechanical_ventilation__observation_id",
      "invasive_mechanical_ventilation__observation_id.x",
      "invasive_mechanical_ventilation__observation_id.y"
    )),
    first_instance_circ       = any_of("circulatory_support_min_1h"),
    first_instance_circ_obsid = any_of(c(
      "circulatory_support_min_1h__observation_id",
      "circulatory_support_min_1h__observation_id.x",
      "circulatory_support_min_1h__observation_id.y"
    ))
  )

# ---------------
# -------------------------------------------------
# Rule 2) Anchor / dayform cross validation
#   A) Screening vs baseline: TRUE/FALSE mismatch
#   B) Baseline type_of_respiratory_support (IMV) vs Dayform1 MV (TRUE/FALSE)
# -------------------------------------------------

# =================================================
# A) Screening vs baseline: TRUE/FALSE mismatch
# =================================================
issue_mv_screen_base_mismatch <- anchor_wide %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    first_trial_dayform_1_to_90_wide %>% mutate(ssid = as.character(ssid)),
    by = "ssid"
  ) %>%
  mutate(
    # mismatch only when both are non-missing and opposite
    rule_violation =
      !is.na(screening__use_of_respiratory_support_at_randomisation) &
      !is.na(baseline__use_of_respiratory_support_at_randomisation) &
      (screening__use_of_respiratory_support_at_randomisation !=
         baseline__use_of_respiratory_support_at_randomisation)
  ) %>%
  filter(rule_violation) %>%
  transmute(
    ssid,
    responsible_site = enrolment_site,

    # obs ids for drill-down
    id_1 = screening__use_of_respiratory_support_at_randomisation__observation_id,
    id_2 = baseline__use_of_respiratory_support_at_randomisation__observation_id,

    variable_name = "screening_vs_baseline_respiratory_support_mismatch",
    issue_type = "hard",
    note = paste0(
      "Mismatch between the use of respiratory support on the screening- and baseline form:  ",
      "screening=", screening__use_of_respiratory_support_at_randomisation,
      ", baseline=", baseline__use_of_respiratory_support_at_randomisation,
      ". Please check both the screening- and baseline-form values for respiratory support"
    )
  )

validation_mv_screen_base_mismatch <- issue_mv_screen_base_mismatch %>%
  transmute(
    ssid,
    id = id_2, # join on screening obs id
    responsible_site,
    variable_name,
    issue_type,
    note
  ) %>%
  left_join(
    anchor %>%
      transmute(
        ssid,
        responsible_site_anchor = responsible_site,
        source = form_layout,
        id = as.character(observation_id),
        time_point = as.character(lubridate::interval(
          lubridate::with_tz(start_datetime, "Europe/Copenhagen"),
          lubridate::with_tz(end_datetime, "Europe/Copenhagen")
        )),
        value
      ),
    by = c("ssid", "id")
  ) %>%
  mutate(responsible_site = coalesce(responsible_site_anchor, responsible_site)) %>%
  select(-responsible_site_anchor) %>%
  relocate(id, ssid, responsible_site, source, time_point, variable_name, value, issue_type, note)

# =================================================
# B) Baseline IMV type vs Dayform1 MV (TRUE/FALSE)
# =================================================
issue_mv_baseline_imv_vs_day1 <- anchor_wide %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    first_trial_dayform_1_to_90_wide %>% mutate(ssid = as.character(ssid)),
    by = "ssid"
  ) %>%
  mutate(
    baseline_imv =
      !is.na(baseline__type_of_respiratory_support) &
      baseline__type_of_respiratory_support == "Invasive mechanical ventilation",

    rule_violation =
      baseline_imv & (is.na(first_instance_mv) | first_instance_mv != TRUE)
  ) %>%
  filter(rule_violation) %>%
  transmute(
    ssid,
    responsible_site = enrolment_site,

    # obs ids for drill-down
    id_1 = baseline__type_of_respiratory_support__observation_id,
    id_2 = first_instance_mv_obsid,

    variable_name = "baseline_imv_requires_day1_mv_true",
    issue_type = "hard",
    note = paste0(
      "Mismatch between the use of invasive mechanical ventilation on the baseline and day form 1:  ",
      "baseline=", baseline__type_of_respiratory_support,
      ", day form 1=", first_instance_mv,
      ". Please check both the baseline and day form 1 values for invasive mechanical ventilation."
    )
  )

validation_mv_baseline_imv_vs_day1 <- issue_mv_baseline_imv_vs_day1 %>%
  transmute(
    ssid,
    id = id_2,  # dayform obs id
    responsible_site,
    variable_name,
    issue_type,
    note
  ) %>%
  left_join(
    first_dayform_1_to_90_long %>%
      transmute(
        ssid,
        responsible_site_dayform = responsible_site,
        source = form_layout,
        id = as.character(observation_id),
        time_point = as.character(lubridate::interval(
          lubridate::with_tz(start_datetime, "Europe/Copenhagen"),
          lubridate::with_tz(end_datetime, "Europe/Copenhagen")
        )),
        value
      ),
    by = c("ssid", "id")
  ) %>%
  mutate(responsible_site = coalesce(responsible_site_dayform, responsible_site)) %>%
  select(-responsible_site_dayform) %>%
  relocate(id, ssid, responsible_site, source, time_point, variable_name, value, issue_type, note)

# =================================================
# Combined output
# =================================================
validation_mechanical_ventilation <- bind_rows(
  validation_mv_screen_base_mismatch,
  validation_mv_baseline_imv_vs_day1
)
```

#### 4.6.4 Circulatory logic check

```{r}
# -------------------------------------------------
#   Cross-check: screening circulatory support (TRUE/FALSE) vs dayform1 first_instance_circ (TRUE/FALSE)
# -------------------------------------------------
issue_circulatory_support <- anchor_wide %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    first_trial_dayform_1_to_90_wide %>% mutate(ssid = as.character(ssid)),
    by = "ssid"
  ) %>%
  mutate(
    # mismatch when screening is TRUE but dayform1 is FALSE/NA,
    # or screening is FALSE but dayform1 is TRUE
    rule_violation =
      (screening__use_of_circulatory_support_at_randomisation %in% TRUE &
         (is.na(first_instance_circ) | first_instance_circ %in% FALSE)) |
      (screening__use_of_circulatory_support_at_randomisation %in% FALSE &
         first_instance_circ %in% TRUE)
  ) %>%
  filter(rule_violation) %>%
  transmute(
    ssid,
    responsible_site = enrolment_site,

    # keep obs ids for drill-down
    id_1 = screening__use_of_circulatory_support_at_randomisation__observation_id,
    id_2 = first_instance_circ_obsid,

    variable_name = "screening_circulatory_support_vs_dayform1_mismatch",
    issue_type = "soft",
    note = paste0(
      "Mismatch between the use circulatory support on the screening- and day form 1:  ",
      "screening=", screening__use_of_circulatory_support_at_randomisation,
      ", day form 1=", first_instance_circ,
      ". Please check both the screening and day form 1 values for circulatory support."
    )
  )

# Join with anchor to long format report:
validation_circulatory_support <- issue_circulatory_support %>%
  transmute(
    ssid,
    id = id_2 ,  # join on the primary observation id (screening circulatory support)
    responsible_site,
    variable_name,
    issue_type,
    note
  ) %>%
  left_join(
    first_dayform_1_to_90_long  %>%
      transmute(
        ssid,
        responsible_site_anchor = responsible_site,
        source = form_layout,
        id = as.character(observation_id),
        time_point = as.character(lubridate::interval(
          lubridate::with_tz(start_datetime, "Europe/Copenhagen"),
          lubridate::with_tz(end_datetime, "Europe/Copenhagen")
        )),
        value
      ),
    by = c("ssid", "id")
  ) %>%
  mutate(
    responsible_site = coalesce(responsible_site_anchor, responsible_site)
  ) %>%
  select(-responsible_site_anchor) %>%
  relocate(
    id, ssid, responsible_site, source, time_point, variable_name, value, issue_type, note
  )
```

```{r}
# -------------------------------------------------
# 2) Validation report
# -------------------------------------------------
validation_cross_form_logicals<- bind_rows(
  validation_critically_illness,
  validation_mechanical_ventilation,
  validation_circulatory_support
) 

# -------------------------------------------------
# Cleanup
# -------------------------------------------------
rm(first_dayform_1_to_90_long,
   first_dayform_ids,
   first_dayform_vals,
   first_trial_dayform_1_to_90_wide,
   issue_critically_illness,
   issue_mv_screen_base_mismatch,
   issue_mv_baseline_imv_vs_day1,
   issue_circulatory_support,
   baseline_vars,
   screening_vars,
   anchor,
   anchor_baseline,
   anchor_screening,
   anchor_wide,
   anchor_wide_ids,
   anchor_wide_vals)
```

#### 4.6.3 Within dayform issues

```{r}

```

## 5.0 Creation of master set for analysis

```{r}
```

### 5.1 Addition of feasibility variables

```{r}
# --------------------------------------------------
# 1) Create one row per ssid with event indicators + time of death (tod)
# --------------------------------------------------
event_flags <- EMPRESS_events %>%
  mutate(
    ssid = as.character(ssid),
    event_type_name = as.character(event_type_name),
    data_collection_allowed = as.character(data_collection_allowed),
    timestamp = ymd_hms(timestamp)
  ) %>%
  group_by(ssid) %>%
  summarise(
    # TRUE if the participant ever died
    death = any(event_type_name == "death", na.rm = TRUE),

    # Time of death (earliest death timestamp)
    tod = {
      death_ts <- timestamp[event_type_name == "death"]
      if (length(death_ts) == 0 || all(is.na(death_ts))) {
        as.POSIXct(NA)
      } else {
        min(death_ts, na.rm = TRUE)
      }
    },

    # TRUE if the participant ever withdrew consent
    withdrawn_consent_empress = any(
      event_type_name == "withdrawn_consent_empress",
      na.rm = TRUE
    ),

    # Data collection allowed logic
    data_collection_allowed = {
      if (!withdrawn_consent_empress) {
        TRUE   # never withdrew → data collection allowed
      } else {
        dca <- data_collection_allowed[
          event_type_name == "withdrawn_consent_empress"
        ]

        if (length(dca) == 0) {
          NA
        } else if (any(dca == "yes", na.rm = TRUE)) {
          TRUE
        } else if (all(is.na(dca))) {
          NA
        } else {
          FALSE
        }
      }
    },

    .groups = "drop"
  )

# --------------------------------------------------
# 2) Join indicators to feasibility master
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(event_flags, by = "ssid") %>%
  mutate(
    death = coalesce(death, FALSE),
    withdrawn_consent_empress = coalesce(withdrawn_consent_empress, FALSE)
    # NOTE: data_collection_allowed intentionally NOT coalesced
  )
```

```{r}
# --------------------------------------------------
# 3) Add treatment allocation 
# --------------------------------------------------
EMPRESS_forms_allocation <- EMPRESS_forms %>%
  left_join(
    EMPRESS_allocation %>%
      select(ssid, allocated_arm),
    by = "ssid"
  )

EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  left_join(
    EMPRESS_allocation %>%
      select(ssid, allocated_arm),
    by = "ssid"
  )
```

```{r}
# --------------------------------------------------
# 4) Identify protocol violations at the row level
# --------------------------------------------------
participants_with_violation <- EMPRESS_forms_allocation %>%
  # Only rows that could possibly generate a violation
  filter(
    value %in% c("By error", "Other reason(s)") |
      (variable_name == "other_antibiotic_agent_than_allocated_type_agent" &
         !is.na(value) & value != "")
  ) %>%
  mutate(
    # Rule 1: explicit protocol deviation reason
    v_reason = value %in% c("By error", "Other reason(s)"),

    # Rule 2: non-allocated antibiotic used (string matching; handles multi-values)
    v_nonallocated =
      (allocated_arm == "meropenem" &
         str_detect(value, fixed("Beta-lactam/beta-lactamase inhibitor", ignore_case = TRUE))) |
      (allocated_arm == "piperacillin/tazobactam" &
         str_detect(value, fixed("Carbapenem (e.g., meropenem)", ignore_case = TRUE))),

    protocol_violation_row = v_reason | v_nonallocated
  ) %>%
  distinct(ssid, observation_id, .keep_all = TRUE) %>%
  group_by(ssid) %>%
  summarise(
    protocol_violation = any(protocol_violation_row, na.rm = TRUE),
    protocol_violation_n = sum(protocol_violation_row %in% TRUE, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # --------------------------------------------------
  # Bring back ALL participants
  # --------------------------------------------------
  right_join(
    EMPRESS_master_feasibility %>% 
      distinct(ssid, allocated_arm),
    by = "ssid"
  ) %>%
  mutate(
    protocol_violation   = replace_na(protocol_violation, FALSE),
    protocol_violation_n = replace_na(protocol_violation_n, 0L),
    allocation = allocated_arm
  ) %>%
  select(ssid, allocation, protocol_violation, protocol_violation_n)

# --------------------------------------------------
# 6) Join protocol violation status and the dummy allocation to feasibility master
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>% 
  left_join(
    participants_with_violation %>% 
      select(ssid, protocol_violation, protocol_violation_n),
    by = "ssid"
  )

rm(
  event_flags, 
  participants_with_violation, 
  EMPRESS_forms_allocation
)
```

### 5.2 Addition of baseline variables

```{r}
# --------------------------------------------------
# 1) Keep baseline, screening and follow-up forms only
# --------------------------------------------------
EMPRESS_forms_baseline <- EMPRESS_forms %>%
  filter(form_layout %in% c(
    "empress_baseline",
    "empress_domain_screening",
    "empress_30_90_days_followup"
  ))

# --------------------------------------------------
# 2) Identify duplicated variables per participant
# --------------------------------------------------
dups <- EMPRESS_forms_baseline %>%
  summarise(n = n(), .by = c(ssid, variable_name)) %>%
  filter(n > 1L)

# --------------------------------------------------
# 3a) Convert NON-microbiology baseline data from long to wide format
# --------------------------------------------------
EMPRESS_forms_baseline_wide <- EMPRESS_forms_baseline %>%
  filter(!variable_name %in% c(
    "type_of_sample",
    "type_of_bacteria",
    "resistance_to_piperacillin_tazobactam",
    "resistance_to_meropenem"
  )) %>%
  select(ssid, variable_name, value) %>%
  mutate(
    ssid  = as.character(ssid),
    value = na_if(trimws(as.character(value)), "")
  ) %>%
  pivot_wider(
    names_from  = variable_name,
    values_from = value,
    values_fn   = ~ dplyr::first(na.omit(.x)),
    values_fill = NA_character_
  )

# --------------------------------------------------
# 3b) Extract 30_90_day_followup value + first_value_change (long -> 1 row/ssid)
# --------------------------------------------------
followup_lookup <- EMPRESS_forms_baseline %>%
  filter(variable_name == "30_90_day_followup") %>%
  transmute(
    ssid                 = as.character(ssid),
    `30_90_day_followup` = na_if(trimws(as.character(value)), ""),
    first_value_change   = first_value_change
  ) %>%
  group_by(ssid) %>%
  summarise(
    `30_90_day_followup` = dplyr::first(na.omit(`30_90_day_followup`)),
    first_value_change   = dplyr::first(na.omit(first_value_change)),
    .groups = "drop"
  )

# --------------------------------------------------
# 3c) Join followup info to feasibility master and place columns after tod
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(followup_lookup, by = "ssid") %>%
  relocate(`30_90_day_followup`, first_value_change, .after = tod)

# --------------------------------------------------
# 4) Create baseline_bacterial_cultures in LONG format
# --------------------------------------------------
baseline_bacterial_cultures <- EMPRESS_forms_baseline %>%
  filter(variable_name %in% c(
    "type_of_sample",
    "type_of_bacteria",
    "resistance_to_piperacillin_tazobactam",
    "resistance_to_meropenem",
    "positive_bacterial_culture"
  )) %>%
  transmute(
    ssid = as.character(ssid),
    childset_group = as.character(childset_group),
    parent_observation_id = as.character(parent_observation_id),
    variable = factor(
      variable_name,
      levels = c(
        "type_of_sample",
        "type_of_bacteria",
        "resistance_to_piperacillin_tazobactam",
        "resistance_to_meropenem",
        "positive_bacterial_culture"
      )
    ),
    value = na_if(trimws(as.character(value)), "")
  ) %>%
  filter(!is.na(value)) %>%
  arrange(
    ssid,
    desc(is.na(childset_group)),  # NA childset_group FIRST (master row)
    childset_group,               # then sort by childset_group
    variable                       # then your enforced variable order
  )

# --------------------------------------------------
# 5) Baseline variables + bacterial flag to feasibility master
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    EMPRESS_forms_baseline_wide %>%
      select(
        ssid,
        date_of_birth,
        sex,
        weight,
        height,
        ischemic_heart_disease,
        diabetes,
        chronic_pulmonary_disease,
        haematological_or_metastatic_cancer,
        immunosuppression,
        organ_transplantation,
        chronic_rrt,
        chronic_liver_disease,
        clinical_frailty_scale,
        limitations_of_care,
        date_of_index_hospital_admission,
        department_at_which_the_participant_was_included,
        acute_surgical_admission,
        primary_site_of_infection,
        positive_bacterial_culture,
        use_of_respiratory_support_at_randomisation,
        type_of_respiratory_support,
        fio2_before_randomisation,
        max_oxygen_flow_at_randomisation,
        arterial_blood_gas_available,
        arterial_oxygen_saturation,
        pao2,
        peripheral_oxygen_saturation,
        systolic_blood_pressure_lowest,
        lactate_highest,
        creatinine_highest,
        use_of_circulatory_support_at_randomisation,
        rrt_within_72h_before_randomisation,
        treatment_with_antibacterial_agent_prior_to_randomisation,
        anti_bacterial_agent
      ),
    by = "ssid"
  ) 

rm(
  dups,
  EMPRESS_forms_baseline,
  EMPRESS_forms_baseline_wide, 
  followup_lookup
)
```

### 5.3 Addition of dayform variables

```{r}
# ==================================================
# 0) Constants / variable sets used throughout
# ==================================================
max_dayforms <- 90L

trial_layout_1_30     <- "empress_dayform_1_to_30"
non_trial_layout_1_30 <- "empress_dayform_non_trial_site_1_to_30"

trial_layout_1_90     <- "empress_dayform_1_to_90"
non_trial_layout_1_90 <- "empress_dayform_non_trial_site_1_to_90"

dayform_layouts <- c(
  trial_layout_1_30, non_trial_layout_1_30,
  trial_layout_1_90, non_trial_layout_1_90
)

# Variables allowed on days 31–90 (ONLY)
vars_31_90_only <- c(
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day"
)

# Dayform variables (trial stream should have all of these)
dayform_vars_all <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "reason_for_not_receiving_at_least_50_percent",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent"
)

# Non-trial stream should only have the "first 10"
dayform_vars_non_trial <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis"
)

# dosing_regimen only comes from empress_dayform_1 (not in 1–30 layouts)
single_vars <- c("dosing_regimen")

# Ordering of variables in long-format output
var_order_full <- c(dayform_vars_all, "dosing_regimen")

# Variable types (for reduction rules)
bool_vars <- c(
  "isolation_due_to_resistant_bacteria",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day"
)

multi_vars <- c(
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "reason_for_not_receiving_at_least_50_percent",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent"
)

# Separators used for merges
sep_multi_stream <- " || "   # between trial and non_trial within transfer-days
sep_multi_within <- "__"     # within-stream de-dup concatenation (keeps existing style)

# Helpers
na_blank <- function(x) {
  x <- str_squish(as.character(x))
  x[x %in% c("", "NA", "NaN")] <- NA_character_
  x
}

to_bool <- function(x) {
  x <- str_to_lower(str_squish(as.character(x)))
  case_when(
    x %in% c("true", "t", "yes", "1")  ~ TRUE,
    x %in% c("false","f","no","0")     ~ FALSE,
    TRUE                              ~ NA
  )
}

tz_local <- "Europe/Copenhagen"
day_start_hour <- 6

utc_to_local_inplace <- function(x, tz_local = "Europe/Copenhagen") {
  # If POSIXct: first treat as UTC instant (no clock shift), then display in local
  if (inherits(x, "POSIXct")) {
    x_utc <- lubridate::force_tz(x, tzone = "UTC")
    return(lubridate::with_tz(x_utc, tzone = tz_local))
  }

  # If character: parse as UTC, then display in local
  x_utc <- suppressWarnings(lubridate::parse_date_time(
    as.character(x),
    orders = c("Ymd HMS","Ymd HM","Y-m-d HMS","Y-m-d HM"),
    tz = "UTC"
  ))
  lubridate::with_tz(x_utc, tzone = tz_local)
}

# ==================================================
# QC helper (optional): participants with both trial + non-trial dayform streams
# ==================================================
test_both_streams <- EMPRESS_forms %>%
  filter(form_layout %in% dayform_layouts) %>%
  mutate(start_datetime = ymd_hms(start_datetime)) %>%
  count(ssid, form_layout) %>%
  filter(n > 1) %>%
  arrange(ssid)

# ==================================================
# 1A) Subset relevant forms
# ==================================================
EMPRESS_forms_dayform_subset <- EMPRESS_forms %>%
  filter(
    (form_layout == "empress_dayform_1" & variable_name %in% single_vars) |
      (form_layout %in% dayform_layouts & variable_name %in% dayform_vars_all)
  ) %>%
  mutate(
    ssid = as.character(ssid),
    start_datetime = utc_to_local_inplace(start_datetime, tz_local = tz_local),
    end_datetime   = utc_to_local_inplace(end_datetime,   tz_local = tz_local)
  )

# ==================================================
# 1B) Randomization reference (rand_time) per ssid
#     - ensure ONE row per ssid
#     - treat rand_datetime_utc as UTC, convert to local before day boundary
# ==================================================
rand0 <- EMPRESS_master_feasibility %>%
  mutate(
    ssid = stringr::str_squish(as.character(ssid)),

    # Parse/standardize: treat source as UTC, then convert to local
    rand_datetime_utc = {
      x <- rand_datetime_utc
      if (!inherits(x, "POSIXct")) x <- lubridate::ymd_hms(x, tz = "UTC")
      lubridate::force_tz(x, tzone = "UTC")
    },
    rand_datetime_local = lubridate::with_tz(rand_datetime_utc, tzone = tz_local),

    # IMPORTANT: compute day in LOCAL tz explicitly
    random_day0 = lubridate::as_date(
      rand_datetime_local - lubridate::hours(day_start_hour),
      tz = tz_local
    )
  ) %>%
  group_by(ssid) %>%
  summarise(
    rand_datetime_utc   = min(rand_datetime_utc, na.rm = TRUE),
    rand_datetime_local = min(rand_datetime_local, na.rm = TRUE),
    random_day0         = min(random_day0, na.rm = TRUE),
    .groups = "drop"
  )

# ==================================================
# 2A) Create stream + clinical day and assign
#     dayform_number as DAYS SINCE RANDOMIZATION
# ==================================================
EMPRESS_forms_dayform_subset_ordered <- EMPRESS_forms_dayform_subset %>%
  mutate(
    ssid = stringr::str_squish(as.character(ssid)),

    # IMPORTANT: compute clinical day in LOCAL tz explicitly
    clinical_day = lubridate::as_date(
      start_datetime - lubridate::hours(day_start_hour),
      tz = tz_local
    ),

    stream = dplyr::case_when(
      form_layout %in% c(trial_layout_1_30, trial_layout_1_90) ~ "trial",
      form_layout %in% c(non_trial_layout_1_30, non_trial_layout_1_90) ~ "non_trial",
      form_layout == "empress_dayform_1" ~ "trial",
      TRUE ~ NA_character_
    ),
    stream = factor(
      stringr::str_to_lower(stringr::str_squish(stream)),
      levels = c("trial", "non_trial")
    ),

    variable_name = factor(as.character(variable_name), levels = var_order_full),

    responsible_site = stringr::str_to_lower(
      stringr::str_squish(as.character(responsible_site))
    ),

    layout_priority = dplyr::case_when(
      form_layout %in% c(trial_layout_1_30, non_trial_layout_1_30) ~ 1L,
      form_layout %in% c(trial_layout_1_90, non_trial_layout_1_90) ~ 2L,
      TRUE ~ 99L
    )
  ) %>%
  left_join(rand0, by = "ssid") %>%
  mutate(
    dayform_number = as.integer(clinical_day - random_day0) + 1L,
    form_number    = paste0("dayform_", dayform_number)
  ) %>%
  filter(
    !is.na(dayform_number),
    dayform_number >= 1L,
    dayform_number <= max_dayforms,

    # 1_to_90 layouts only contribute the 3 vars
    !(form_layout %in% c(trial_layout_1_90, non_trial_layout_1_90) &
        !(as.character(variable_name) %in% vars_31_90_only))
  ) %>%
  arrange(ssid, dayform_number, layout_priority, start_datetime, variable_name) %>%
  ungroup() %>%
  select(-clinical_day) %>%
  relocate(form_number, .after = ssid)

# ==================================================
# 2B) Day existence flags: dayform_real_1 ... dayform_real_30
#     TRUE  = day exists in the export (at least one record that day)
#     FALSE = no exported records for that day (will be all-NA later)
# ==================================================
dayform_real_flags <- EMPRESS_forms_dayform_subset_ordered %>%
  mutate(
    day_num = as.integer(str_extract(form_number, "(?<=dayform_)\\d+"))
  ) %>%
  distinct(ssid, day_num) %>%
  mutate(dayform_real = TRUE) %>%
  tidyr::complete(ssid, day_num = 1:max_dayforms, fill = list(dayform_real = FALSE)) %>%
  mutate(flag_name = paste0("dayform_real_", day_num)) %>%
  select(ssid, flag_name, dayform_real) %>%
  tidyr::pivot_wider(
    names_from = flag_name,
    values_from = dayform_real,
    values_fill = FALSE
  )

# ==================================================
# 3) Fill missing variables per ssid + form_number + stream
#    - trial stream gets ALL 15 dayform vars
#    - non_trial stream gets first 10 only
#    - only applied for stream days that exist (no synthetic streams created)
# ==================================================
# Which stream-days exist?
stream_days <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  distinct(ssid, form_number, dayform_number, stream)

# Expected variable grid for existing stream-days
expected_trial <- stream_days %>%
  filter(stream == "trial") %>%
  tidyr::crossing(variable_name = dayform_vars_all) %>%
  # On days 31–90, keep ONLY the 3 variables
  filter(dayform_number <= 30L | variable_name %in% vars_31_90_only)

expected_non_trial <- stream_days %>%
  filter(stream == "non_trial") %>%
  tidyr::crossing(variable_name = dayform_vars_non_trial) %>%
  # On days 31–90, keep ONLY the 3 variables
  filter(dayform_number <= 30L | variable_name %in% vars_31_90_only)

expected_all <- bind_rows(expected_trial, expected_non_trial) %>%
  transmute(
    ssid = as.character(ssid),
    form_number,
    stream = as.character(stream),
    variable_name = as.character(variable_name)
  )

# Existing keys
existing_keys <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  transmute(
    ssid = as.character(ssid),
    form_number,
    stream = as.character(stream),
    variable_name = as.character(variable_name)
  ) %>%
  distinct()

# Identify missing rows to create
missing_rows_keys <- expected_all %>%
  anti_join(existing_keys, by = c("ssid", "form_number", "stream", "variable_name"))

# Template (1 row per ssid + form_number + stream) to copy metadata
template_cols <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  group_by(ssid, form_number, stream) %>%
  slice(1) %>%
  ungroup() %>%
  select(-variable_name, -value)

# Build missing rows with NA values
missing_rows_full <- missing_rows_keys %>%
  left_join(template_cols, by = c("ssid", "form_number", "stream")) %>%
  mutate(
    variable_name = as.character(variable_name),
    value = NA_character_
  )

# Bind back and order deterministically
EMPRESS_forms_dayform_filled <- bind_rows(
  EMPRESS_forms_dayform_subset_ordered,
  missing_rows_full
) %>%
  mutate(
    day_num = as.integer(str_extract(form_number, "(?<=dayform_)\\d+")),
    variable_name = factor(as.character(variable_name), levels = var_order_full)
  ) %>%
  arrange(ssid, day_num, stream, variable_name, start_datetime) %>%  # start_datetime is now local
  select(-day_num)

# ==================================================
# 4) Merge trial/non-trial within same dayform (transfer-days)
#    - merge_this_day: TRUE if both streams exist in the same ssid+form_number
# ==================================================
merge_map <- EMPRESS_forms_dayform_filled %>%
  filter(stream %in% c("trial","non_trial")) %>%
  group_by(ssid, form_number) %>%
  summarise(
    n_streams = n_distinct(stream),

    # distinct sites within each stream-day
    n_sites_trial = n_distinct(responsible_site[stream == "trial" & !is.na(responsible_site)]),
    n_sites_nontrial = n_distinct(responsible_site[stream == "non_trial" & !is.na(responsible_site)]),

    # merge if transfer OR same-stream split across sites
    merge_this_day = (n_streams > 1) | (n_sites_trial > 1) | (n_sites_nontrial > 1),
    .groups = "drop"
  ) %>%
  select(ssid, form_number, merge_this_day)

df <- EMPRESS_forms_dayform_filled %>%
  left_join(merge_map, by = c("ssid","form_number")) %>%
  mutate(merge_this_day = coalesce(merge_this_day, FALSE))

# ==================================================
# 5) Reduce boolean variables within each ssid + form_number
#    - TRUE overrides FALSE; otherwise FALSE; otherwise NA
# ==================================================
day_bool <- df %>%
  filter(as.character(variable_name) %in% bool_vars) %>%
  mutate(val_bool = to_bool(value)) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = dplyr::case_when(
      any(val_bool %in% TRUE,  na.rm = TRUE) ~ "TRUE",
      any(val_bool %in% FALSE, na.rm = TRUE) ~ "FALSE",
      TRUE                                   ~ NA_character_
    ),
    .groups = "drop"
  )

# ==================================================
# 6) Reduce multi-value variables
#    A) Not transfer-days: keep first value by time (may be NA)
#    B) Transfer-days: merge trial + non_trial within dayform
#       - within each stream: de-duplicate repeated identical values (keeps first occurrence)
#       - between streams: combine with " || "
#       - CURRENT behavior is "lenient": keep available stream if the other is NA
# ==================================================
# Helper to collapse values within a group (unique, keep order)
collapse_unique <- function(x, sep = "__") {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_character_)
  x <- x[!duplicated(x)]
  paste(x, collapse = sep)
}

df_multi <- df %>% 
  filter(as.character(variable_name) %in% multi_vars) %>%
  mutate(
    value  = na_blank(value),

    # IMPORTANT: enforce exact stream names used in pivot
    stream = case_when(
      as.character(stream) %in% c("trial")      ~ "trial",
      as.character(stream) %in% c("non_trial")  ~ "non_trial",
      as.character(stream) %in% c("nontrial")   ~ "non_trial",  # safety
      TRUE ~ NA_character_
    )
  )

# A) Not split days
day_multi_not_merged <- df_multi %>%
  filter(!merge_this_day) %>%
  arrange(ssid, form_number, variable_name, layout_priority, start_datetime) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(value = dplyr::first(value), .groups = "drop")

# B1) Split days: merge within stream
day_multi_split_stream <- df_multi %>%
  filter(merge_this_day) %>%
  arrange(ssid, form_number, variable_name, stream, layout_priority, start_datetime) %>%
  group_by(ssid, form_number, variable_name, stream) %>%
  summarise(v_stream = collapse_unique(value, sep = sep_multi_within), .groups = "drop")

# B2) Combine streams
# helper: ensure columns exist (create as NA if missing)
ensure_cols <- function(df, cols, fill = NA_character_) {
  missing <- setdiff(cols, names(df))
  if (length(missing) > 0) {
    df[missing] <- fill
  }
  df
}

day_multi_merged <- day_multi_split_stream %>%
  tidyr::pivot_wider(
    names_from  = stream,
    values_from = v_stream,
    values_fill = NA_character_
  ) %>%
  ensure_cols(c("trial", "non_trial"), fill = NA_character_) %>%  # <--- key line
  mutate(
    value = dplyr::case_when(
      !is.na(trial) & !is.na(non_trial) ~ paste(trial, non_trial, sep = sep_multi_stream),
      !is.na(trial)                    ~ trial,
      !is.na(non_trial)                ~ non_trial,
      TRUE                             ~ NA_character_
    )
  ) %>%
  select(ssid, form_number, variable_name, value)

day_multi_long <- dplyr::bind_rows(day_multi_not_merged, day_multi_merged)

# ==================================================
# 7) Reduce single-value variable(s): dosing_regimen
# ==================================================
day_single <- df %>%
  filter(as.character(variable_name) %in% single_vars) %>%
  mutate(v = na_if(str_squish(as.character(value)), "")) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = dplyr::first(na.omit(v)),
    .groups = "drop"
  )

# ==================================================
# 8) Combine all reduced outputs, then pivot wide (1 row per ssid)
# ==================================================
day_merged_long <- bind_rows(day_bool, day_multi_long, day_single) %>%
  mutate(
    ssid  = as.character(ssid),
    value = as.character(value),
    var_day = paste0(form_number, "__", as.character(variable_name))
  ) %>%
  select(ssid, var_day, value)

EMPRESS_dayforms_wide_1row <- day_merged_long %>%
  pivot_wider(
    id_cols     = ssid,
    names_from  = var_day,
    values_from = value,
    values_fn   = ~ dplyr::first(na.omit(.x)),
    values_fill = NA_character_
  )

# ==================================================
# 9) Force expected wide columns (dayforms 1–30; dosing_regimen day 1 only)
#    - Force ALL dayform_vars_all for all days + dosing_regimen for day 1
# ==================================================
expected_cols <- c(
  # Days 1–30: full variable set
  expand_grid(var_nm = dayform_vars_all, day_num = 1:30) %>%
    mutate(col = paste0("dayform_", day_num, "__", var_nm)) %>%
    pull(col),

  # Days 31–90: only the 3 variables
  expand_grid(var_nm = vars_31_90_only, day_num = 31:max_dayforms) %>%
    mutate(col = paste0("dayform_", day_num, "__", var_nm)) %>%
    pull(col),

  "dayform_1__dosing_regimen"
)

missing_cols <- setdiff(expected_cols, names(EMPRESS_dayforms_wide_1row))

if (length(missing_cols) > 0) {
  EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
    tibble::add_column(!!!setNames(rep(list(NA_character_), length(missing_cols)), missing_cols))
}

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  select(ssid, all_of(expected_cols))

# ==================================================
# 10) Reorder wide columns by VARIABLE (dayform_vars_all order) then Dayform number (1–30)
#     - dosing_regimen only exists on day 1; placed after the 15 dayform_vars_all by default
# ==================================================
var_order_wide <- c(dayform_vars_all, "dosing_regimen")

dayform_cols <- names(EMPRESS_dayforms_wide_1row) %>%
  setdiff("ssid") %>%
  tibble(col = .) %>%
  mutate(
    day_num  = as.integer(str_extract(col, "(?<=dayform_)\\d+")),
    var_nm   = str_replace(col, "^dayform_\\d+__", ""),
    var_rank = match(var_nm, var_order_wide)
  ) %>%
  # push anything unexpected to the end 
  mutate(
    var_rank = if_else(is.na(var_rank), 9999L, var_rank),
    day_num  = if_else(is.na(day_num), 9999L, day_num)
  ) %>%
  arrange(var_rank, day_num, col) %>%
  pull(col)

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  mutate(ssid = str_squish(as.character(ssid))) %>%
  select(ssid, all_of(dayform_cols))

# ==================================================
# 10B) Add dayform_real_* flags to the wide dayform dataset (robust)
#      - ensure ssid matches (trim)
#      - convert any NA flags to FALSE (in case of non-matching ssid)
# ==================================================
dayform_real_cols <- paste0("dayform_real_", 1:max_dayforms)

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  left_join(
    dayform_real_flags %>%
      mutate(ssid = str_squish(as.character(ssid))),
    by = "ssid"
  ) %>%
  mutate(
    across(any_of(dayform_real_cols), ~ replace_na(.x, FALSE))
  )

# ==================================================
# 11) Join to feasibility master (must happen BEFORE relocate)
# ==================================================
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = stringr::str_squish(as.character(ssid))) %>%
  left_join(EMPRESS_dayforms_wide_1row, by = "ssid") %>%
  # extra safety: ensure flags are not NA after the join
  mutate(
    across(dplyr::any_of(dayform_real_cols), ~ tidyr::replace_na(.x, FALSE))
  )

# ==================================================
# 11B) Reorder columns: place dayform_real_1..30 right after anti_bacterial_agent
#      - use any_of() to avoid errors if something is missing
# ==================================================
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  dplyr::relocate(dplyr::any_of(dayform_real_cols), .after = anti_bacterial_agent)

# ==================================================
# Cleanup (optional)
# ==================================================
rm(
  EMPRESS_forms_dayform_subset,
  EMPRESS_forms_dayform_subset_ordered,
  EMPRESS_forms_dayform_filled,
  missing_rows_keys,
  missing_rows_full,
  template_cols,
  expected_trial,
  expected_non_trial,
  expected_all,
  existing_keys,
  stream_days,
  merge_map,
  df,
  df_multi,
  day_bool,
  day_multi_not_merged,
  day_multi_merged,
  day_multi_long,
  day_single,
  day_merged_long,
  EMPRESS_dayforms_wide_1row,
  dayform_real_flags
)
```

```{r}
cols_with_pipes <- EMPRESS_master_feasibility %>%
  summarise(
    across(
      where(is.character),
      ~ any(str_detect(.x, fixed("||")), na.rm = TRUE)
    )
  ) %>%
  pivot_longer(everything(),
               names_to = "column",
               values_to = "contains_pipes") %>%
  filter(contains_pipes)

cols_with_pipes
```
