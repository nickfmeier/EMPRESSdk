---
title: "EMPRESS feasibility"
author: "NM"
date: "2025-12-12"
output: html_document
---

# EMPRESS feasibility study analyses

<https://regionh-my.sharepoint.com/:w:/g/personal/nick_froerup_meier_regionh_dk/IQB77RUBVR5LRpMrM9MIP5W7ATida8z_XRIar06T04DKuv8?CID=058350ee-05a2-8497-1263-53a6c6200dd8>

## Change log

-   Version 1.0, date: 18-12-2025: First version drafted and reviewed with AG and CTA.

-   Version 1.1, date:

    -   Removed space between lettering and changed full variable name to lower bracket in section 3.4 subsection 3.

    -   Stratified event_type to separate variables in section 3.1 subsection 1 + 2.

    -   Rearranged day form variables so each variable is forced to be repeated 30 times (even for ssid's with only 7 day forms) before moving on the next variable within day form 1 in section in section 3.4, subsection 1 through 5.

    -   Added responsible site to the overview of potential outliers in section 4.2, subsection 2. **NB. enrollment site or responsible site?**

    -   Parsed the values for Clinical Frailty Scale from e.g., "1. Very Fit" to whole numeric for analysis in section 3.5, subsection 2.

    -   Parsed all categorical yes/no variables to logical statements where yes = TRUE and no = FALSE, in section 3.5, subsection 3.

    -   Added a general validation section as section 4.1, containing 4.1.1: validation of structure and type, 4.1.2: day form logics [insert further here]

    -   Changed the way microbiological samples are displayed in baseline variables, now a positive sample is depicted as TRUE/FALSE and a long secondary data frame has been created to accommodate if participants have multiple positive samples (multiple rows) at baseline in section 3.4, subsection 4 and 5.

    -   Converted all yes and no responses to TRUE and FALSE, respectively, see section 3.6, subsection 2.

    -   Refactored the EMPRESS dayform extraction in section 3.4 and transformation pipeline to correctly handle trial → non-trial transfers, enforce expected variables per stream/day, standardize ordering, and produce a consistent 1-row-per-participant wide dataset. Removed ad-hoc test code and consolidated constants and helper functions.

## 0.0 Setting up GitHub enviroment

```{r}
update.packages(ask = FALSE, checkBuilt = TRUE)
```

## 1.0 Load libraries

```{r include=FALSE}
library(nanoparquet)
library(tidyverse)
library(openxlsx)
library(stringi)
library(janitor)
```

## 2.0 Load data

```{r include=FALSE}
# -------- Paths to exported data files --------
data_dir <- "C:/Users/nmei0013/Downloads"
f_forms <- file.path(data_dir, "export-export_forms_empress_domain_20251221105418.parquet")
f_events <- file.path(data_dir, "export-export_events_empress_platform_20251209150608.parquet")
allocation <- file.path(data_dir, "export-export_allocations_empress_domain_20251212112744.parquet")

# -------- Load data from parquet files --------
EMPRESS_forms <- read_parquet(f_forms)
EMPRESS_events <- read_parquet(f_events)
EMPRESS_allocation <- read_parquet(allocation)
```

## 3.0 Data cleaning

### 3.1 Creation of master set

```{r}
# Use EMPRESS_events to define first 200 participants included
EMPRESS_feasibility_master <- EMPRESS_events %>% 
  # keep only enrolment rows
  filter(str_detect(event_type_name, "enrolment")) %>% 
  
  # order by time to pick the FIRST 200 enrolled participants
  arrange(timestamp) %>% 
  
  # pick first 200 unique ssid
  distinct(ssid, .keep_all = TRUE) %>% 
  slice_head(n = 200) %>% 
  
  # rename timestamp to rand_time
  rename(rand_time = timestamp) %>%
  
  # keep only relevant columns
  select(ssid, enrolment_site, rand_time)
```

### 3.2 Addition of feasibility variables

Notes to section 1):

| Scenario           | Withdrawn | data_collection_allowed |
|--------------------|-----------|-------------------------|
| Never withdrew     | FALSE     | FALSE                   |
| Withdrew + yes     | TRUE      | TRUE                    |
| Withdrew + no      | TRUE      | FALSE                   |
| Withdrew + NA only | TRUE      | NA                      |

```{r}
# --------------------------------------------------
# 1) Create one row per ssid with event indicators + time of death (tod)
# --------------------------------------------------
event_flags <- EMPRESS_events %>%
  mutate(
    ssid = as.character(ssid),
    event_type_name = as.character(event_type_name),
    data_collection_allowed = as.character(data_collection_allowed),
    timestamp = ymd_hms(timestamp)
  ) %>%
  group_by(ssid) %>%
  summarise(
    # TRUE if the participant ever died
    death = any(event_type_name == "death", na.rm = TRUE),

    # Time of death (earliest parsable death timestamp)
    tod = {
      death_ts <- timestamp[event_type_name == "death"]
      if (length(death_ts) == 0 || all(is.na(death_ts))) {
        as.POSIXct(NA)
      } else {
        min(death_ts, na.rm = TRUE)
      }
    },

    # TRUE if the participant ever withdrew consent
    withdrawn_consent_empress = any(
      event_type_name == "withdrawn_consent_empress",
      na.rm = TRUE
    ),

    # NA-aware data collection flag
    data_collection_allowed = {
      dca <- data_collection_allowed[event_type_name == "withdrawn_consent_empress"]

      if (length(dca) == 0) {
        FALSE                         # no withdrawal → not allowed
      } else if (any(dca == "yes", na.rm = TRUE)) {
        TRUE                          # at least one explicit YES
      } else if (all(is.na(dca))) {
        NA                            # withdrawal but only NA info
      } else {
        FALSE                         # explicit NO (possibly mixed with NA)
      }
    },

    .groups = "drop"
  )

# --------------------------------------------------
# 2) Join indicators to feasibility master
# --------------------------------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(event_flags, by = "ssid") %>%
  mutate(
    death = coalesce(death, FALSE),
    withdrawn_consent_empress = coalesce(withdrawn_consent_empress, FALSE)
    # NOTE: data_collection_allowed is intentionally NOT coalesced
  )

# --------------------------------------------------
# 3) Create dummy treatment allocation (for testing)
# --------------------------------------------------
# Randomly assign each participant to one treatment arm
# (used only for testing / development purposes)
set.seed(2025)  # ensure reproducibility

EMPRESS_forms_allocation <- EMPRESS_forms %>% 
  group_by(ssid) %>% 
  mutate(
    allocation = sample(c("meropenem", "piperacillin/tazobactam"), 1)
  ) %>% 
  ungroup()

# --------------------------------------------------
# 4) Identify protocol violations at the row level
# --------------------------------------------------
participants_with_violation <- EMPRESS_forms_allocation %>% 
  filter(
    # Explicit protocol deviation reasons
    value %in% c("By error", "Other reason(s)") |
    
    # Use of non-allocated antibiotic
    (variable_name == "use_of_any_another_antibiotic_agent_than_allocated_on_this_day" &
       value == "Yes") |
    
    # Empirical treatment instead of allocated treatment
    (variable_name == "other_antibiotic_agent_than_allocated_type_treatment" &
       value == "Empirical treatment") |
    
    # Any recorded alternative antibiotic agent
    (variable_name == "other_antibiotic_agent_than_allocated_type_agent" &
       !is.na(value) & value != "")
  ) %>% 
  mutate(
    # Define protocol violation logic per row
    protocol_violation = case_when(
      value %in% c("By error", "Other reason(s)") ~ TRUE,
      value == "piperacillin/tazobactam" & allocation == "meropenem" ~ TRUE,
      value == "meropenem" & allocation == "piperacillin/tazobactam" ~ TRUE,
      TRUE ~ FALSE
    )
  ) %>% 
  # --------------------------------------------------
  # 5) Collapse to one row per participant
  # --------------------------------------------------
  group_by(ssid) %>% 
  summarise(
  allocation = first(allocation),
  protocol_violation = any(protocol_violation, na.rm = TRUE),
  protocol_violation_n = sum(protocol_violation %in% TRUE, na.rm = TRUE), # optional: keep count
  .groups = "drop"
)

# --------------------------------------------------
# 6) Join protocol violation status and the dummy allocation to feasibility master
# --------------------------------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>% 
  left_join(
    participants_with_violation %>% 
      select(ssid, allocation, protocol_violation),
    by = "ssid"
  )

rm(
  event_flags, 
  participants_with_violation, 
  EMPRESS_forms_allocation
)
```

### 3.3 Addition of baseline variables

```{r}
# --------------------------------------------------
# 1) Keep baseline, screening and follow-up forms only
# --------------------------------------------------
EMPRESS_forms_baseline <- EMPRESS_forms %>%
  filter(form_layout %in% c(
    "empress_baseline",
    "empress_domain_screening",
    "empress_30_90_days_followup"
  ))

# --------------------------------------------------
# 2) Identify duplicated variables per participant
# --------------------------------------------------
dups <- EMPRESS_forms_baseline %>%
  summarise(n = n(), .by = c(ssid, variable_name)) %>%
  filter(n > 1L)

# --------------------------------------------------
# 3a) Convert NON-microbiology baseline data from long to wide format
# --------------------------------------------------
EMPRESS_forms_baseline_wide <- EMPRESS_forms_baseline %>%
  filter(!variable_name %in% c(
    "type_of_sample",
    "type_of_bacteria",
    "resistance_to_piperacillin_tazobactam",
    "resistance_to_meropenem"
  )) %>%
  select(ssid, variable_name, value) %>%
  mutate(
    ssid  = as.character(ssid),
    value = na_if(trimws(as.character(value)), "")
  ) %>%
  pivot_wider(
    names_from  = variable_name,
    values_from = value,
    values_fn   = ~ dplyr::first(na.omit(.x)),
    values_fill = NA_character_
  )

# --------------------------------------------------
# 3b) Extract 30_90_day_followup value + first_value_change (long -> 1 row/ssid)
# --------------------------------------------------
followup_lookup <- EMPRESS_forms_baseline %>%
  filter(variable_name == "30_90_day_followup") %>%
  transmute(
    ssid                 = as.character(ssid),
    `30_90_day_followup` = na_if(trimws(as.character(value)), ""),
    first_value_change   = first_value_change
  ) %>%
  group_by(ssid) %>%
  summarise(
    `30_90_day_followup` = dplyr::first(na.omit(`30_90_day_followup`)),
    first_value_change   = dplyr::first(na.omit(first_value_change)),
    .groups = "drop"
  )

# --------------------------------------------------
# 3c) Join followup info to feasibility master and place columns after tod
# --------------------------------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(followup_lookup, by = "ssid") %>%
  relocate(`30_90_day_followup`, first_value_change, .after = tod)

# --------------------------------------------------
# 4) Create baseline_bacterial_cultures in LONG format
# --------------------------------------------------
baseline_bacterial_cultures <- EMPRESS_forms_baseline %>%
  filter(variable_name %in% c(
    "type_of_sample",
    "type_of_bacteria",
    "resistance_to_piperacillin_tazobactam",
    "resistance_to_meropenem",
    "positive_bacterial_culture"
  )) %>%
  transmute(
    ssid = as.character(ssid),
    childset_group = as.character(childset_group),
    parent_observation_id = as.character(parent_observation_id),
    variable = factor(
      variable_name,
      levels = c(
        "type_of_sample",
        "type_of_bacteria",
        "resistance_to_piperacillin_tazobactam",
        "resistance_to_meropenem",
        "positive_bacterial_culture"
      )
    ),
    value = na_if(trimws(as.character(value)), "")
  ) %>%
  filter(!is.na(value)) %>%
  arrange(
    ssid,
    desc(is.na(childset_group)),  # NA childset_group FIRST (master row)
    childset_group,               # then sort by childset_group
    variable                       # then your enforced variable order
  )

# --------------------------------------------------
# 5) Baseline variables + bacterial flag to feasibility master
# --------------------------------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    EMPRESS_forms_baseline_wide %>%
      select(
        ssid,
        date_of_birth,
        sex,
        weight,
        height,
        ischemic_heart_disease,
        diabetes,
        chronic_pulmonary_disease,
        haematological_or_metastatic_cancer,
        immunosuppression,
        organ_transplantation,
        chronic_rrt,
        chronic_liver_disease,
        clinical_frailty_scale,
        limitations_of_care,
        date_of_index_hospital_admission,
        department_at_which_the_participant_was_included,
        acute_surgical_admission,
        primary_site_of_infection,
        positive_bacterial_culture,
        use_of_respiratory_support_at_randomisation,
        type_of_respiratory_support,
        fio2_before_randomisation,
        max_oxygen_flow_at_randomisation,
        arterial_blood_gas_available,
        arterial_oxygen_saturation,
        pao2,
        peripheral_oxygen_saturation,
        systolic_blood_pressure_lowest,
        lactate_highest,
        creatinine_highest,
        use_of_circulatory_support_at_randomisation,
        rrt_within_72h_before_randomisation,
        treatment_with_antibacterial_agent_prior_to_randomisation,
        anti_bacterial_agent
      ),
    by = "ssid"
  ) 

rm(
  dups,
  EMPRESS_forms_baseline,
  EMPRESS_forms_baseline_wide, 
  followup_lookup
)
```

### 3.4 Addition of treatment and outcome variables

```{r}
# ==================================================
# 0) Constants / variable sets used throughout
# ==================================================

# Layout names
trial_layout     <- "empress_dayform_1_to_30"
non_trial_layout <- "empress_dayform_non_trial_site_1_to_30"
dayform_layouts  <- c(trial_layout, non_trial_layout)

# Dayform variables (trial stream should have all of these)
dayform_vars_all <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "reason_for_not_receiving_at_least_50_percent",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent"
)

# Non-trial stream should only have the "first 10"
dayform_vars_non_trial <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis"
)

# dosing_regimen only comes from empress_dayform_1 (not in 1–30 layouts)
single_vars <- c("dosing_regimen")

# Ordering of variables in long-format output
var_order_full <- c(dayform_vars_all, "dosing_regimen")

# Variable types (for reduction rules)
bool_vars <- c(
  "isolation_due_to_resistant_bacteria",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day"
)

multi_vars <- c(
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "reason_for_not_receiving_at_least_50_percent",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent"
)

# Separators used for merges
sep_multi_stream <- " || "   # between trial and non_trial within transfer-days
sep_multi_within <- "__"     # within-stream de-dup concatenation (keeps existing style)

# Helpers
na_blank <- function(x) {
  x <- str_squish(as.character(x))
  x[x %in% c("", "NA", "NaN")] <- NA_character_
  x
}

to_bool <- function(x) {
  x <- str_to_lower(str_squish(as.character(x)))
  case_when(
    x %in% c("true", "t", "yes", "1")  ~ TRUE,
    x %in% c("false","f","no","0")     ~ FALSE,
    TRUE                              ~ NA
  )
}

# ==================================================
# QC helper (optional): participants with both trial + non-trial dayform streams
# ==================================================
test_both_streams <- EMPRESS_forms %>%
  filter(form_layout %in% dayform_layouts) %>%
  mutate(start_datetime = ymd_hms(start_datetime)) %>%
  count(ssid, form_layout) %>%
  filter(n > 1) %>%
  arrange(ssid)

# ==================================================
# 1) Subset relevant records from EMPRESS_forms
#    - dosing_regimen only from empress_dayform_1
#    - dayform variables from trial/non-trial 1–30 layouts
# ==================================================
EMPRESS_forms_dayform_subset <- EMPRESS_forms %>%
  filter(
    (form_layout == "empress_dayform_1" & variable_name %in% single_vars) |
      (form_layout %in% dayform_layouts & variable_name %in% dayform_vars_all)
  ) %>%
  mutate(
    ssid = as.character(ssid),
    start_datetime = ymd_hms(start_datetime)
  )

# ==================================================
# 2) Create stream + day_key, then assign dayform_number/form_number by DATE per ssid
# ==================================================
EMPRESS_forms_dayform_subset_ordered <- EMPRESS_forms_dayform_subset %>%
  mutate(
    day_key = as.Date(start_datetime),

    # stream assignment
    stream = case_when(
      form_layout == trial_layout ~ "trial",
      form_layout == non_trial_layout ~ "non_trial",
      form_layout == "empress_dayform_1" ~ "trial",  # dosing_regimen treated as trial-side
      TRUE ~ NA_character_
    ),
    stream = factor(str_to_lower(str_squish(stream)), levels = c("trial", "non_trial"))
  ) %>%
  arrange(ssid, day_key, start_datetime, variable_name) %>%
  group_by(ssid) %>%
  mutate(
    dayform_number = dense_rank(day_key),
    form_number = paste0("dayform_", dayform_number)
  ) %>%
  ungroup() %>%
  select(-day_key) %>%
  relocate(form_number, .after = ssid)

# ==================================================
# 3) Fill missing variables per ssid + form_number + stream
#    - trial stream gets ALL 15 dayform vars
#    - non_trial stream gets first 10 only
#    - only applied for stream days that exist (no synthetic streams created)
# ==================================================

# Which stream-days exist?
stream_days <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  distinct(ssid, form_number, stream)

# Expected variable grid for existing stream-days
expected_trial <- stream_days %>%
  filter(stream == "trial") %>%
  tidyr::crossing(variable_name = dayform_vars_all)

expected_non_trial <- stream_days %>%
  filter(stream == "non_trial") %>%
  tidyr::crossing(variable_name = dayform_vars_non_trial)

expected_all <- bind_rows(expected_trial, expected_non_trial) %>%
  transmute(
    ssid = as.character(ssid),
    form_number,
    stream = as.character(stream),
    variable_name = as.character(variable_name)
  )

# Existing keys
existing_keys <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  transmute(
    ssid = as.character(ssid),
    form_number,
    stream = as.character(stream),
    variable_name = as.character(variable_name)
  ) %>%
  distinct()

# Identify missing rows to create
missing_rows_keys <- expected_all %>%
  anti_join(existing_keys, by = c("ssid", "form_number", "stream", "variable_name"))

# Template (1 row per ssid + form_number + stream) to copy metadata
template_cols <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  group_by(ssid, form_number, stream) %>%
  slice(1) %>%
  ungroup() %>%
  select(-variable_name, -value)

# Build missing rows with NA values
missing_rows_full <- missing_rows_keys %>%
  left_join(template_cols, by = c("ssid", "form_number", "stream")) %>%
  mutate(
    variable_name = as.character(variable_name),
    value = NA_character_
  )

# Bind back and order deterministically
EMPRESS_forms_dayform_filled <- bind_rows(
  EMPRESS_forms_dayform_subset_ordered,
  missing_rows_full
) %>%
  mutate(
    # numeric day for correct ordering (dayform_2 before dayform_10)
    day_num = as.integer(str_extract(form_number, "(?<=dayform_)\\d+")),
    variable_name = factor(as.character(variable_name), levels = var_order_full)
  ) %>%
  arrange(ssid, day_num, stream, variable_name, start_datetime) %>%
  select(-day_num)

# ==================================================
# 4) Merge trial/non-trial within same dayform (transfer-days)
#    - merge_this_day: TRUE if both streams exist in the same ssid+form_number
# ==================================================
merge_map <- EMPRESS_forms_dayform_filled %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  distinct(ssid, form_number, stream) %>%
  count(ssid, form_number, stream) %>%
  pivot_wider(names_from = stream, values_from = n, values_fill = 0) %>%
  mutate(merge_this_day = (trial > 0 & non_trial > 0)) %>%
  select(ssid, form_number, merge_this_day)

df <- EMPRESS_forms_dayform_filled %>%
  left_join(merge_map, by = c("ssid", "form_number")) %>%
  mutate(merge_this_day = coalesce(merge_this_day, FALSE))

# ==================================================
# 5) Reduce boolean variables within each ssid + form_number
#    - TRUE overrides FALSE; otherwise FALSE; otherwise NA
# ==================================================
day_bool <- df %>%
  filter(as.character(variable_name) %in% bool_vars) %>%
  mutate(val_bool = to_bool(value)) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = case_when(
      any(val_bool %in% TRUE,  na.rm = TRUE) ~ "TRUE",
      any(val_bool %in% FALSE, na.rm = TRUE) ~ "FALSE",
      TRUE                                   ~ NA_character_
    ),
    .groups = "drop"
  )

# ==================================================
# 6) Reduce multi-value variables
#    A) Not transfer-days: keep first value by time (may be NA)
#    B) Transfer-days: merge trial + non_trial within dayform
#       - within each stream: de-duplicate repeated identical values (keeps first occurrence)
#       - between streams: combine with " || "
#       - CURRENT behavior is "lenient": keep available stream if the other is NA
# ==================================================
df_multi <- df %>%
  filter(as.character(variable_name) %in% multi_vars) %>%
  mutate(
    value  = na_blank(value),
    stream = factor(as.character(stream), levels = c("trial", "non_trial"))
  )

# A) Not merged days
day_multi_not_merged <- df_multi %>%
  filter(!merge_this_day) %>%
  arrange(ssid, form_number, variable_name, start_datetime) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = dplyr::first(value),
    .groups = "drop"
  )

# B) Merged days: build one value per stream, then combine streams
day_multi_merged <- df_multi %>%
  filter(merge_this_day) %>%
  arrange(ssid, form_number, variable_name, stream, start_datetime) %>%
  group_by(ssid, form_number, variable_name, stream) %>%
  summarise(
    v_stream = {
      vals <- value[!is.na(value)]
      if (length(vals) == 0) NA_character_
      else paste(vals[!duplicated(vals)], collapse = sep_multi_within)
    },
    .groups = "drop"
  ) %>%
  pivot_wider(
    names_from  = stream,
    values_from = v_stream,
    values_fill = NA_character_
  ) %>%
  mutate(
    # Lenient merge rule (current): keep whichever stream exists if the other is missing
    value = case_when(
      !is.na(trial) & !is.na(non_trial) ~ paste(trial, non_trial, sep = sep_multi_stream),
      !is.na(trial)                    ~ trial,
      !is.na(non_trial)                ~ non_trial,
      TRUE                             ~ NA_character_
    )
  ) %>%
  select(ssid, form_number, variable_name, value)

day_multi_long <- bind_rows(day_multi_not_merged, day_multi_merged)

# ==================================================
# 7) Reduce single-value variable(s): dosing_regimen
# ==================================================
day_single <- df %>%
  filter(as.character(variable_name) %in% single_vars) %>%
  mutate(v = na_if(str_squish(as.character(value)), "")) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = dplyr::first(na.omit(v)),
    .groups = "drop"
  )

# ==================================================
# 8) Combine all reduced outputs, then pivot wide (1 row per ssid)
# ==================================================
day_merged_long <- bind_rows(day_bool, day_multi_long, day_single) %>%
  mutate(
    ssid  = as.character(ssid),
    value = as.character(value),
    var_day = paste0(form_number, "__", as.character(variable_name))
  ) %>%
  select(ssid, var_day, value)

EMPRESS_dayforms_wide_1row <- day_merged_long %>%
  pivot_wider(
    id_cols     = ssid,
    names_from  = var_day,
    values_from = value,
    values_fn   = ~ dplyr::first(na.omit(.x)),
    values_fill = NA_character_
  )

# --------------------------------------------------
# QC1: transfer-days collapse check (2 streams -> 1)
# --------------------------------------------------

# Identify transfer-days at the "filled" long stage (your df has merge_map joined)
qc_transfer_keys <- df %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  distinct(ssid, form_number, stream, merge_this_day) %>%
  group_by(ssid, form_number) %>%
  summarise(
    merge_this_day = any(merge_this_day),
    n_streams      = n_distinct(stream),
    streams        = paste(sort(unique(as.character(stream))), collapse = ", "),
    .groups = "drop"
  ) %>%
  filter(merge_this_day)

# Expected: all rows here should have n_streams == 2
qc_transfer_keys_problem <- qc_transfer_keys %>%
  filter(n_streams != 2)

# --------------------------------------------------
# QC2: uniqueness after reduction (no duplicate keys)
# --------------------------------------------------
qc_duplicates_after_reduction <- bind_rows(day_bool, day_multi_long, day_single) %>%
  count(ssid, form_number, variable_name) %>%
  filter(n > 1) %>%
  arrange(desc(n), ssid, form_number, variable_name)

# --------------------------------------------------
# QC3: content validation for transfer-days (multi-vars)
# --------------------------------------------------

# Recompute expected merged value for transfer-days from df_multi
qc_expected_multi <- df_multi %>%
  filter(merge_this_day) %>%
  arrange(ssid, form_number, variable_name, stream, start_datetime) %>%
  group_by(ssid, form_number, variable_name, stream) %>%
  summarise(
    v_stream = {
      vals <- value[!is.na(value)]
      if (length(vals) == 0) NA_character_
      else paste(vals[!duplicated(vals)], collapse = sep_multi_within)
    },
    .groups = "drop"
  ) %>%
  tidyr::pivot_wider(
    names_from  = stream,
    values_from = v_stream,
    values_fill = NA_character_
  ) %>%
  mutate(
    expected_value = dplyr::case_when(
      !is.na(trial) & !is.na(non_trial) ~ paste(trial, non_trial, sep = sep_multi_stream),
      !is.na(trial)                    ~ trial,
      !is.na(non_trial)                ~ non_trial,
      TRUE                             ~ NA_character_
    )
  ) %>%
  select(ssid, form_number, variable_name, expected_value)

# Compare to produced value from your pipeline (day_multi_merged)
qc_compare_multi <- day_multi_merged %>%
  left_join(qc_expected_multi, by = c("ssid", "form_number", "variable_name")) %>%
  mutate(
    match = dplyr::case_when(
      is.na(value) & is.na(expected_value) ~ TRUE,
      value == expected_value              ~ TRUE,
      TRUE                                 ~ FALSE
    )
  )

qc_multi_mismatches <- qc_compare_multi %>%
  filter(!match) %>%
  arrange(ssid, form_number, variable_name)

# --------------------------------------------------
# QC4 (optional): show before/after for transfer-days
# --------------------------------------------------

# Before: per stream raw (multi vars only)
qc_before <- df_multi %>%
  filter(merge_this_day) %>%
  arrange(ssid, form_number, variable_name, stream, start_datetime) %>%
  group_by(ssid, form_number, variable_name, stream) %>%
  summarise(raw_values = paste(na.omit(value), collapse = " | "), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = stream, values_from = raw_values)

# After: reduced merged value
qc_after <- day_multi_merged %>%
  rename(reduced_value = value)

qc_spotcheck <- qc_before %>%
  left_join(qc_after, by = c("ssid", "form_number", "variable_name")) %>%
  arrange(ssid, form_number, variable_name)

qc_spotcheck

# ==================================================
# 9) Force expected wide columns (dayforms 1–30; dosing_regimen day 1 only)
#    - Force ALL dayform_vars_all for all days + dosing_regimen for day 1
# ==================================================
expected_cols <- c(
  expand_grid(var_nm = dayform_vars_all, day_num = 1:30) %>%
    mutate(col = paste0("dayform_", day_num, "__", var_nm)) %>%
    pull(col),
  "dayform_1__dosing_regimen"
)

missing_cols <- setdiff(expected_cols, names(EMPRESS_dayforms_wide_1row))

if (length(missing_cols) > 0) {
  EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
    tibble::add_column(!!!setNames(rep(list(NA_character_), length(missing_cols)), missing_cols))
}

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  select(ssid, all_of(expected_cols))

# ==================================================
# 10) Reorder wide columns by VARIABLE (dayform_vars_all order) then Dayform number (1–30)
#    - dosing_regimen only exists on day 1; placed after the 15 dayform_vars_all by default
# ==================================================
var_order_wide <- c(dayform_vars_all, "dosing_regimen")

dayform_cols <- names(EMPRESS_dayforms_wide_1row) %>%
  setdiff("ssid") %>%
  tibble(col = .) %>%
  mutate(
    day_num  = as.integer(str_extract(col, "(?<=dayform_)\\d+")),
    var_nm   = str_replace(col, "^dayform_\\d+__", ""),
    var_rank = match(var_nm, var_order_wide)
  ) %>%
  # push anything unexpected to the end (QC friendly)
  mutate(
    var_rank = if_else(is.na(var_rank), 9999L, var_rank),
    day_num  = if_else(is.na(day_num), 9999L, day_num)
  ) %>%
  arrange(var_rank, day_num, col) %>%
  pull(col)

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  select(ssid, all_of(dayform_cols))

# ==================================================
# 11) Join to feasibility master
# ==================================================
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(EMPRESS_dayforms_wide_1row, by = "ssid")

# ==================================================
# 12) QC: participants present in both datasets
# ==================================================
shared_ssids <- EMPRESS_feasibility_master %>%
  semi_join(EMPRESS_dayforms_wide_1row, by = "ssid") %>%
  distinct(ssid)

# ==================================================
# Cleanup (optional)
# ==================================================
rm(
  EMPRESS_forms_dayform_subset,
  EMPRESS_forms_dayform_subset_ordered,
  EMPRESS_forms_dayform_filled,
  missing_rows_keys,
  missing_rows_full,
  template_cols,
  expected_trial,
  expected_non_trial,
  expected_all,
  existing_keys,
  stream_days,
  merge_map,
  df,
  df_multi,
  day_bool,
  day_multi_not_merged,
  day_multi_merged,
  day_multi_long,
  day_single,
  day_merged_long,
  EMPRESS_dayforms_wide_1row,
  shared_ssids
)
```

#### 3.4.1 Creation of dummy master for validation purposes

##### 3.4.1.1 Create dummy baseline variables

```{r}
set.seed(20251215)

# Sample 1–k categories and paste them together with "__"
# - p_k controls how often you get 1 vs 2 vs 3 values
# - replace = FALSE avoids duplicates within the same person (A__A)
sample_cat_multi <- function(n, choices, probs = NULL,
                             p_k = c(`1` = 0.70, `2` = 0.22, `3` = 0.08),
                             sep = "__",
                             p_na = 0.05) {

  # number of values per row (1–3)
  k <- sample(as.integer(names(p_k)), size = n, replace = TRUE, prob = as.numeric(p_k))

  out <- vapply(seq_len(n), function(i) {
    # if probs are provided, ensure we sample without replacement with weights
    vals <- sample(choices, size = k[i], replace = FALSE, prob = probs)
    paste(vals, collapse = sep)
  }, FUN.VALUE = character(1))

  # apply NA injection using your existing helper (keeps style consistent)
  out <- sample_na(out, p_na = p_na)
  out
}

# ----------------------------
# 0) Load master (pre-validation)
# ----------------------------
EMPRESS_feasibility_master_SIMULATED <- EMPRESS_feasibility_master

# ----------------------------
# 1) Helper sampling functions
# ----------------------------
sample_na <- function(x, p_na = 0.02) {
  # randomly set some values to NA
  ifelse(runif(length(x)) < p_na, NA, x)
}

sample_cat <- function(n, choices, probs = NULL, p_na = 0.05) {
  out <- sample(choices, size = n, replace = TRUE, prob = probs)
  out <- sample_na(out, p_na = p_na)
  out
}

sample_num <- function(n, minv, maxv, p_na = 0.05, round_to = NULL) {
  out <- runif(n, minv, maxv)
  if (!is.null(round_to)) out <- round(out, round_to)
  out <- sample_na(out, p_na = p_na)
  out
}

# ----------------------------
# 2) Fill BASELINE-like fields (one row per ssid)
# ----------------------------
n <- nrow(EMPRESS_feasibility_master_SIMULATED)

# Ensure rand_time exists and is POSIXct (keep existing if already correct)
EMPRESS_feasibility_master_SIMULATED <- EMPRESS_feasibility_master_SIMULATED %>%
  mutate(
    rand_time = as.POSIXct(rand_time, tz = "Europe/Copenhagen")
  )

# Create plausible DOB and admission dates relative to rand_time
EMPRESS_feasibility_master_SIMULATED <- EMPRESS_feasibility_master_SIMULATED %>%
  mutate(
    allocation = sample_cat(n, c("meropenem","piperacillin/tazobactam"), probs = c(0.50, 0.50), p_na = 0.00),
    sex = sample_cat(n, c("female","male"), probs = c(0.45, 0.55), p_na = 0.00),

    # DOB: age 18–95 mostly, with a few >95 up to 115 to test flags
    age_target = sample(
      c(sample(18:95, size = ceiling(n*0.95), replace = TRUE),
        sample(96:115, size = n - ceiling(n*0.95), replace = TRUE))
    ),
    date_of_birth = as.Date(rand_time) - years(age_target) - days(sample(0:364, n, replace = TRUE)),

    # Admission date: usually before rand_time; make some invalid after rand_time
    date_of_index_hospital_admission = as.Date(rand_time) - sample(0:14, n, replace = TRUE),
    date_of_index_hospital_admission = if_else(runif(n) < 0.05, as.Date(rand_time) + sample(1:5, n, TRUE), date_of_index_hospital_admission),

    weight = sample_num(n, 45, 140, p_na = 0.02, round_to = 1),      # kg
    height = sample_num(n, 150, 200, p_na = 0.02, round_to = 0),     # cm

    ischemic_heart_disease = sample_cat(n, c("yes","no"), probs = c(0.25,0.75), p_na = 0.01),
    diabetes               = sample_cat(n, c("yes","no"), probs = c(0.20,0.80), p_na = 0.01),
    chronic_pulmonary_disease = sample_cat(n, c("yes","no"), probs = c(0.18,0.82), p_na = 0.01),
    haematological_or_metastatic_cancer = sample_cat(n, c("yes","no"), probs = c(0.10,0.90), p_na = 0.01),
    immunosuppression      = sample_cat(n, c("yes","no"), probs = c(0.12,0.88), p_na = 0.01),
    organ_transplantation  = sample_cat(n, c("yes","no"), probs = c(0.05,0.95), p_na = 0.01),
    chronic_rrt            = sample_cat(n, c("yes","no"), probs = c(0.06,0.94), p_na = 0.01),
    chronic_liver_disease  = sample_cat(n, c("yes","no"), probs = c(0.08,0.92), p_na = 0.01),
    limitations_of_care    = sample_cat(n, c("yes","no"), probs = c(0.20,0.80), p_na = 0.01),

    clinical_frailty_scale = sample_cat(
      n,
      c("1. Very Fit","2. Fit","3. Managing Well","4. Living with Very Mild Frailty","5. Living with Mild Frailty",
        "6. Living with Moderate Frailty","7. Living with Severe Frailty","8. Living with Very Severe Frailty","9 Terminally Ill"),
      probs = c(0.12,0.16,0.18,0.14,0.14,0.12,0.07,0.05,0.02),
      p_na = 0.01
    ),

    department_at_which_the_participant_was_included = sample_cat(
      n,
      c("emergency_department","hospital_ward","intermediate_care_unit","intensive_care_unit"),
      probs = c(0.05,0.05,0.05,0.85),
      p_na = 0.01
    ),

    acute_surgical_admission = sample_cat(n, c("yes","no"), probs = c(0.25,0.75), p_na = 0.01),
    
    use_of_circulatory_support_at_randomisation = sample_cat(n, c("yes","no"), probs = c(0.25,0.75), p_na = 0.01),
    
    rrt_within_72h_before_randomisation = sample_cat(n, c("yes","no"), probs = c(0.25,0.75), p_na = 0.01),

    primary_site_of_infection = sample_cat(
      n,
      c("pulmonary","gastrointestinal","urinary_tract","skin_or_soft_tissue","bloodstream","other_including_unknown"),
      probs = c(0.38,0.16,0.16,0.10,0.08,0.12),
      p_na = 0.01
    ),

    # Vitals / labs (with occasional extremes for validation tests)
    systolic_blood_pressure_lowest = sample_num(n, 60, 160, p_na = 0.01, round_to = 0),
    lactate_highest                = sample_num(n, 0.8, 10, p_na = 0.01, round_to = 1),
    creatinine_highest             = sample_num(n, 40, 800, p_na = 0.01, round_to = 0),

    # Occasionally inject implausible values to test soft/hard validation
    lactate_highest    = if_else(runif(n) < 0.03, sample_num(n, 20, 35, p_na = 0, round_to = 1), lactate_highest),
    creatinine_highest = if_else(runif(n) < 0.02, sample_num(n, 1500, 2500, p_na = 0, round_to = 0), creatinine_highest),

    # Prior antibiotics branching
    treatment_with_antibacterial_agent_prior_to_randomisation = sample_cat(n, c("yes","no"), probs = c(0.45,0.55), p_na = 0.01)
  ) %>%
  mutate(
    anti_bacterial_agent = if_else(
      treatment_with_antibacterial_agent_prior_to_randomisation == "yes",
      sample_cat_multi(
        n(),
        c("betalactam_betalactamaseinhibitor","carbapenem","cephalosporin","penicillin","glycopeptide",
          "fluoroquinolone","macrolide","lincosamides","nitroimidazole","aminoglycoside","oxazolidinone",
          "sulfonamide","tetracycline","polymyxin","other_antibacterial_agents"),
        probs = c(0.20,0.10,0.12,0.10,0.06,0.06,0.06,0.03,0.04,0.05,0.03,0.02,0.02,0.01,0.10),
        p_k   = c(`1` = 0.70, `2` = 0.22, `3` = 0.08),  # adjust frequency of multi-values
        sep   = "__",
        p_na  = 0.01
      ),
      NA_character_
    ),
    # allow occasional “mistake NA even though yes” for testing
    anti_bacterial_agent = if_else(
      treatment_with_antibacterial_agent_prior_to_randomisation == "yes" & runif(n()) < 0.05,
      NA_character_,
      anti_bacterial_agent
    )
  ) %>%
  # Culture branching
  mutate(
    positive_bacterial_culture = sample_cat(n, c("yes","no"), probs = c(0.40,0.60), p_na = 0.01)
  ) %>%
  
  # Respiratory support branching
  mutate(
    # (Re)generate parent variables if they don't already exist / are messy
    use_of_respiratory_support_at_randomisation =
      if_else(is.na(use_of_respiratory_support_at_randomisation) | str_squish(as.character(use_of_respiratory_support_at_randomisation)) == "",
              sample_cat(n(), c("yes","no"), probs = c(0.55,0.45), p_na = 0.02),
              str_to_lower(str_squish(as.character(use_of_respiratory_support_at_randomisation)))),

    # If support == yes, sample a type; else NA
    type_of_respiratory_support = if_else(
      use_of_respiratory_support_at_randomisation == "yes",
      if_else(is.na(type_of_respiratory_support) | str_squish(as.character(type_of_respiratory_support)) == "",
              sample(
                c("supplementary_oxygen_flow_ge_10_l_min",
                  "supplementary_oxygen_flow_lt_10_l_min",
                  "invasive_mechanical_ventilation",
                  "noninvasive_ventilation",
                  "continuous_use_of_cpap"),
                size = n(), replace = TRUE,
                prob = c(0.25, 0.30, 0.20, 0.15, 0.10)
              ),
              str_squish(as.character(type_of_respiratory_support))),
      NA_character_
    ),

    # Ensure children are numeric (important for if_else type safety)
    max_oxygen_flow_at_randomisation = suppressWarnings(as.numeric(max_oxygen_flow_at_randomisation)),
    fio2_before_randomisation        = suppressWarnings(as.numeric(fio2_before_randomisation)),

    # If NO resp support -> children must be NA
    max_oxygen_flow_at_randomisation = if_else(
      use_of_respiratory_support_at_randomisation == "no",
      NA_real_, max_oxygen_flow_at_randomisation
    ),
    fio2_before_randomisation = if_else(
      use_of_respiratory_support_at_randomisation == "no",
      NA_real_, fio2_before_randomisation
    ),

    # If supplementary_oxygen_flow_ge_10_l_min -> max oxygen MUST be filled (numeric)
    max_oxygen_flow_at_randomisation = if_else(
      use_of_respiratory_support_at_randomisation == "yes" &
        type_of_respiratory_support == "supplementary_oxygen_flow_ge_10_l_min" &
        is.na(max_oxygen_flow_at_randomisation),
      round(runif(n(), 10, 60)),   # L/min
      max_oxygen_flow_at_randomisation
    ),

    # If supplementary_oxygen_flow_lt_10_l_min -> give a plausible value (optional, but nice)
    max_oxygen_flow_at_randomisation = if_else(
      use_of_respiratory_support_at_randomisation == "yes" &
        type_of_respiratory_support == "supplementary_oxygen_flow_lt_10_l_min" &
        is.na(max_oxygen_flow_at_randomisation),
      round(runif(n(), 1, 9)),     # L/min
      max_oxygen_flow_at_randomisation
    ),

    # If ventilation/NIV/CPAP -> FiO2 MUST be filled (numeric 0-1)
    fio2_before_randomisation = if_else(
      use_of_respiratory_support_at_randomisation == "yes" &
        type_of_respiratory_support %in% c(
          "invasive_mechanical_ventilation",
          "noninvasive_ventilation",
          "continuous_use_of_cpap"
        ) &
        is.na(fio2_before_randomisation),
      round(runif(n(), 0.21, 1.00), 2),
      fio2_before_randomisation
    )
  ) %>%
  # ABG branching
  mutate(
    arterial_blood_gas_available = sample_cat(n, c("yes","no"), probs = c(0.55,0.45), p_na = 0.02),
    arterial_oxygen_saturation = if_else(
      arterial_blood_gas_available == "yes",
      sample_num(n, 75, 100, p_na = 0.02, round_to = 0),
      NA_real_
    ),
    pao2 = if_else(
      arterial_blood_gas_available == "yes",
      sample_num(n, 5, 18, p_na = 0.02, round_to = 1),  # kPa
      NA_real_
    ),
    peripheral_oxygen_saturation = if_else(
      arterial_blood_gas_available == "no",
      sample_num(n, 75, 100, p_na = 0.02, round_to = 0),
      NA_real_
    )
  ) %>%
  select(-age_target)
```

##### 3.4.1.2 Create dummy dayform variables

```{r}
# ==================================================
# 1) Fill DAYFORM-derived fields (FORCE day 1–30 repetitions)
#    - Creates synthetic repeated dayform variables for ALL included variables
#    - Ensures correct dependencies (child vars only filled when parent says "yes"/"no")
#    - Overwrites any existing dayform_* columns in EMPRESS_feasibility_master_SIMULATED
# ==================================================

# Define the day range you want
day_nums <- 1:30

# Dayform variables to simulate (ALL included variables)
day_vars <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "reason_for_not_receiving_at_least_50_percent",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent",
  "dosing_regimen" # only day 1
)

# Identify existing dayform columns so we can overwrite them
dayform_cols_existing <- names(EMPRESS_feasibility_master_SIMULATED) %>%
  str_subset("^dayform_\\d+__")

# ----------------------------
# 2) Create long grid: one row per ssid x dayform (ALWAYS 1..30)
# ----------------------------
day_long <- EMPRESS_feasibility_master_SIMULATED %>%
  distinct(ssid) %>%
  mutate(ssid = as.character(ssid)) %>%
  crossing(day = day_nums) %>%
  mutate(
    # dosing_regimen: ONLY Dayform 1; other days forced to NA
    dosing_regimen = if_else(
      day == 1L,
      sample_cat(n(), c("intermittent_infusion", "prolonged_infusion"),
                 probs = c(0.6, 0.4), p_na = 0.01),
      NA_character_
    ),

    # --- Isolation logic (parent -> children) ---
    isolation_due_to_resistant_bacteria =
      sample_cat(n(), c("yes", "no"), probs = c(0.20, 0.80), p_na = 0.01),

    type_of_resistant_bacteria_new = if_else(
      isolation_due_to_resistant_bacteria == "yes",
      sample_cat(
        n(),
        c("acinetobacter_baumanii","citrobacter","clostridiodies_difficile","enterobacter",
          "enterococcus_faecium","e_coli","klebsiella","proteus_mirabilis","pseudomonas",
          "staphylococcus_aureus","streptococcus_pneumoniae","other_bacteria"),
        p_na = 0.01
      ),
      NA_character_
    ),

    antibiotic_agent_to_which_the_bacteria_was_resistant = if_else(
      isolation_due_to_resistant_bacteria == "yes",
      sample_cat(
        n(),
        c("amikacin","amoxicillin_clavulanate","ampicillin","aztreonam","aztreonam_avibactam",
          "benzylpenicillin","cefazolin","cefepime","cefepime_enmetazobactam","cefiderocol",
          "cefotaxime","cefoxitin","ceftazidime","ceftazidime_avibactam","ceftolozane_tazobactam",
          "ceftriaxone","cefuroxime","ciprofloxacin","clindamycin","colistin","dalbavancin",
          "daptomycin","dicloxacillin","doxycycline","ertapenem","flucloxacillin","fosfomycin",
          "gentamicin","imipenem","imipenem_cilastatin_relebactam","levofloxacin","linezolid",
          "meropenem","meropenem_vaborbactam","metronidazole","moxifloxacin","piperacillin_tazobactam",
          "teicoplanin","tigecycline","tobramycin","trimethoprim_sulfamethoxazole","vancomycin",
          "other_antibacterial_agents"),
        p_na = 0.01
      ),
      NA_character_
    ),

    # --- Daily support / complications (independent booleans) ---
    invasive_mechanical_ventilation =
      sample_cat(n(), c("yes","no"), probs = c(0.35,0.65), p_na = 0.01),

    circulatory_support_min_1h =
      sample_cat(n(), c("yes","no"), probs = c(0.30,0.70), p_na = 0.01),

    any_rrt_this_day =
      sample_cat(n(), c("yes","no"), probs = c(0.10,0.90), p_na = 0.01),

    anaphylactic_shock_piptazo_meropenem =
      sample_cat(n(), c("yes","no"), probs = c(0.02,0.98), p_na = 0.01),

    invasive_fungal_infection =
      sample_cat(n(), c("yes","no"), probs = c(0.05,0.95), p_na = 0.01),

    pseudomembranous_colitis =
      sample_cat(n(), c("yes","no"), probs = c(0.02,0.98), p_na = 0.01),

    toxic_epidermal_necrolysis =
      sample_cat(n(), c("yes","no"), probs = c(0.01,0.99), p_na = 0.01),

    # --- Dose adherence logic (parent -> reason) ---
    did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose =
      sample_cat(n(), c("yes","no"), probs = c(0.75,0.25), p_na = 0.02),

    reason_for_not_receiving_at_least_50_percent = if_else(
      did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose == "no",
      sample_cat(
        n(),
        c("change_to_definitive_treatment",
          "deescalation_to_another_empirical_antibiotics",
          "empirical_or_definitive_antibiotic_treatment_no_longer_indicated",
          "discharged_to_non_participating_department",
          "clinical_deterioration_with_indication_for_different_antibiotic",
          "adverse_reaction_to_allocated_agent",
          "by_error",
          "other_reason"),
        probs = c(0.25,0.10,0.10,0.08,0.08,0.10,0.18,0.11),
        p_na = 0.03
      ),
      NA_character_
    ),

    # --- Other antibiotic logic (parent -> treatment type + agent type) ---
    use_of_any_another_antibiotic_agent_than_allocated_on_this_day =
      sample_cat(n(), c("yes","no"), probs = c(0.25,0.75), p_na = 0.06),

    other_antibiotic_agent_than_allocated_type_treatment = if_else(
      use_of_any_another_antibiotic_agent_than_allocated_on_this_day == "yes",
      sample_cat(n(),
                 c("prophylactic_treatment","empirical_treatment","definitive_treatment"),
                 probs = c(0.15,0.55,0.30),
                 p_na = 0.02),
      NA_character_
    ),

    other_antibiotic_agent_than_allocated_type_agent = if_else(
      use_of_any_another_antibiotic_agent_than_allocated_on_this_day == "yes",
      sample_cat(n(),
                 c("betalactam_betalactamaseinhibitor","carbapenem","cephalosporin","penicillin",
                   "glycopeptide","fluoroquinolone","macrolide","nitroimidazole","aminoglycoside",
                   "oxazolidinone","sulfonamide","tetracycline","polymyxin","other_antibacterial_agents"),
                 p_na = 0.02),
      NA_character_
    )
  ) %>%
  # Inject a few "mistake NAs" where the child SHOULD be filled (for validation testing)
  mutate(
    reason_for_not_receiving_at_least_50_percent = if_else(
      did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose == "no" & runif(n()) < 0.05,
      NA_character_,
      reason_for_not_receiving_at_least_50_percent
    ),
    other_antibiotic_agent_than_allocated_type_treatment = if_else(
      use_of_any_another_antibiotic_agent_than_allocated_on_this_day == "yes" & runif(n()) < 0.05,
      NA_character_,
      other_antibiotic_agent_than_allocated_type_treatment
    ),
    # OPTIONAL: also inject mistakes for isolation children (uncomment if useful)
    # type_of_resistant_bacteria_new = if_else(
    #   isolation_due_to_resistant_bacteria == "yes" & runif(n()) < 0.05,
    #   NA_character_,
    #   type_of_resistant_bacteria_new
    # ),
    # antibiotic_agent_to_which_the_bacteria_was_resistant = if_else(
    #   isolation_due_to_resistant_bacteria == "yes" & runif(n()) < 0.05,
    #   NA_character_,
    #   antibiotic_agent_to_which_the_bacteria_was_resistant
    # )
  )

# ----------------------------
# 2) Convert to wide columns matching master naming: "dayform_X__var"
#    - dosing_regimen exists ONLY on day 1
# ----------------------------
day_long_wide <- day_long %>%
  pivot_longer(cols = all_of(day_vars), names_to = "var", values_to = "val") %>%
  filter(!(var == "dosing_regimen" & day != 1L)) %>%
  mutate(
    colname = paste0("dayform_", day, "__", var),
    var = factor(var, levels = day_vars)
  ) %>%
  arrange(ssid, day, var) %>%
  select(ssid, colname, val) %>%
  pivot_wider(names_from = colname, values_from = val)

# ----------------------------
# 3) Join synthetic dayform values into master (overwrite existing dayform columns)
# ----------------------------
EMPRESS_feasibility_master_SIMULATED <- EMPRESS_feasibility_master_SIMULATED %>%
  mutate(ssid = as.character(ssid)) %>%
  select(-all_of(dayform_cols_existing)) %>%
  left_join(day_long_wide, by = "ssid")

# ----------------------------
# 4) Reorder dayform columns by VARIABLE order first, then by Dayform number (1–30)
#    - i.e., dayform_1__isolation ... dayform_30__isolation first,
#      then dayform_1__type_of_resistant ... dayform_30__type_of_resistant, etc.
# ----------------------------
day_cols_new <- names(EMPRESS_feasibility_master_SIMULATED) %>%
  str_subset("^dayform_\\d+__") %>%
  tibble(col = .) %>%
  mutate(
    day_num  = as.integer(str_extract(col, "(?<=dayform_)\\d+")),
    var_nm   = str_replace(col, "^dayform_\\d+__", ""),
    var_rank = match(var_nm, day_vars)
  ) %>%
  # push anything unexpected to the very end (robustness)
  mutate(
    var_rank = if_else(is.na(var_rank), 9999L, var_rank),
    day_num  = if_else(is.na(day_num), 9999L, day_num)
  ) %>%
  arrange(var_rank, day_num, col) %>%   # <-- KEY CHANGE: var first, then day
  pull(col)

EMPRESS_feasibility_master_SIMULATED <- EMPRESS_feasibility_master_SIMULATED %>%
  select(
    all_of(setdiff(names(.), day_cols_new)),
    all_of(day_cols_new)
  )
```

# ------------------------------------------

# NEEDS TO BE REMOVED BEFORE ANALYSIS

```{r}
EMPRESS_feasibility_master <- EMPRESS_feasibility_master_SIMULATED
```

# ------------------------------------------

### 3.5 Parsing and standardising across multiple variables

```{r}
# ----------------------------
# 1) Reusable helpers
# ----------------------------
# ---- name cleaning that also handles Danish letters ----
clean_names_strict <- function(df) {
  nm <- names(df)

  nm <- stringi::stri_trans_general(nm, "Latin-ASCII")  # æøå -> aeoaa-ish
  nm <- janitor::make_clean_names(nm)                   # lower_snake_case
  nm <- gsub("\\.+", "_", nm)                           # remove dots -> _
  nm <- gsub("_+", "_", nm)                             # collapse __
  nm <- gsub("^_|_$", "", nm)                           # trim underscores

  names(df) <- nm
  df
}

# ---- numeric parser (comma thousands, dot decimals) ----
num <- function(x) {
  readr::parse_number(
    as.character(x),
    locale = readr::locale(decimal_mark = ".", grouping_mark = ",")
  )
}

# ---- date/time parsing ----
parse_dt_safe <- function(x, tz = "Europe/Copenhagen") {
  x <- str_squish(as.character(x))
  x[x %in% c("", "NA", "NaN")] <- NA_character_

  suppressWarnings(
    lubridate::parse_date_time(
      x,
      orders = c(
        "Ymd HMS", "Ymd HM", "Ymd",
        "Y-m-d HMS", "Y-m-d HM", "Y-m-d",
        "dmy HMS", "dmy HM", "dmy",
        "dmY HMS", "dmY HM", "dmY",
        "d/m/Y HMS", "d/m/Y HM", "d/m/Y",
        "Y/m/d HMS", "Y/m/d HM", "Y/m/d"
      ),
      tz = tz
    )
  )
}

parse_date_safe <- function(x) as.Date(parse_dt_safe(x))

# ---- robust TRUE/FALSE parsing (keeps NA) ----
to_logical <- function(x) {
  x <- str_to_lower(str_squish(as.character(x)))
  x[x %in% c("", "na", "nan")] <- NA_character_

  dplyr::case_when(
    x %in% c("true","t","yes","y","1")  ~ TRUE,
    x %in% c("false","f","no","n","0")  ~ FALSE,
    TRUE ~ NA
  )
}

# ---- standardize categorical text (lowercase, underscores, NA for blanks) ----
to_cat <- function(x) {
  x <- str_squish(as.character(x))
  x[x %in% c("", "NA", "NaN")] <- NA_character_
  x <- str_to_lower(x)
  x <- str_replace_all(x, "[^a-z0-9]+", "_")  # spaces/special -> _
  x <- str_replace_all(x, "_+", "_")
  x <- str_replace_all(x, "^_|_$", "")
  x
}

# ---- apply transformations safely only to columns that exist ----
pick_existing <- function(df, cols) intersect(cols, names(df))

# ----------------------------
# 2) Standardise + parse EMPRESS_feasibility_master
# ----------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  clean_names_strict() %>%
  rename(
    followup_30 = x30_90_day_followup
  ) %>%
  mutate(
    ssid = as.character(ssid)
  )

# ---- define column groups (edit these lists as needed) ----
datetime_cols <- c("rand_time")
date_cols     <- c("date_of_birth", "date_of_index_hospital_admission")

# keep sex as male/female (not logical)
sex_cols <- c("sex")

# binary columns -> TRUE/FALSE
logical_cols <- c(
  "death",
  "followup_30",
  "withdrawn_consent_empress",
  "data_collection_allowed",
  "ischemic_heart_disease",
  "diabetes",
  "chronic_pulmonary_disease",
  "haematological_or_metastatic_cancer",
  "immunosuppression",
  "organ_transplantation",
  "chronic_rrt",
  "chronic_liver_disease",
  "limitations_of_care",
  "acute_surgical_admission",
  "use_of_respiratory_support_at_randomisation",
  "arterial_blood_gas_available",
  "use_of_circulatory_support_at_randomisation",
  "rrt_within_72h_before_randomisation",
  "treatment_with_antibacterial_agent_prior_to_randomisation",
  "positive_bacterial_culture"
)

# categorical columns -> standardized text (optionally convert to factor later)
cat_cols <- c(
  "enrolment_site",
  "allocation",
  "department_at_which_the_participant_was_included",
  "primary_site_of_infection",
  "type_of_respiratory_support",
  "anti_bacterial_agent",
  "clinical_frailty_scale" # will be parsed numeric later, but standardize first if messy
)

num_cols <- c(
  "protocol_violation",
  "weight",
  "height",
  "systolic_blood_pressure_lowest",
  "fio2_before_randomisation",
  "max_oxygen_flow_at_randomisation",
  "arterial_oxygen_saturation",
  "pao2",
  "peripheral_oxygen_saturation",
  "lactate_highest",
  "creatinine_highest"
)

# ---- apply transformations safely only to columns that exist ----
pick_existing <- function(df, cols) intersect(cols, names(df))

EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(
    across(all_of(pick_existing(., datetime_cols)), parse_dt_safe),
    across(all_of(pick_existing(., date_cols)), parse_date_safe),
    across(all_of(pick_existing(., sex_cols)),  ~ to_cat(.x)),         # male/female stays text
    across(all_of(pick_existing(., logical_cols)), to_logical),
    across(all_of(pick_existing(., cat_cols)), to_cat),
    across(all_of(pick_existing(., num_cols)), num)
  )

# ----------------------------
# 3) Format clinical_frailty_scale for analysis
# ----------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(
    clinical_frailty_scale = case_when(
      is.na(clinical_frailty_scale) ~ NA_real_,
      TRUE ~ as.numeric(str_extract(as.character(clinical_frailty_scale), "^\\d+"))
    )
  )

# ----------------------------
# 4) Age calculation
# ----------------------------
EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(
    age_years = if_else(
      !is.na(date_of_birth) & !is.na(rand_time),
      floor(time_length(interval(date_of_birth, rand_time), "years")),
      NA_real_
    ),
    .after = date_of_birth
  )

# ----------------------------
# 5) Parse / standardise DAYFORM repeated variables (dayform_1..30)
#    - uses regex that matches dayform_<n>__<var>
# ----------------------------

day_bool_vars <- c(
  "isolation_due_to_resistant_bacteria",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day"
)

day_cat_vars <- c(
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "reason_for_not_receiving_at_least_50_percent",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent",
  "dosing_regimen"
)

# Build regex for each set: ^dayform_<number>__<var>$
bool_pattern <- paste0("^dayform_\\d+_(", paste(day_bool_vars, collapse = "|"), ")$")
cat_pattern  <- paste0("^dayform_\\d+_(", paste(day_cat_vars,  collapse = "|"), ")$")

day_bool_cols <- names(EMPRESS_feasibility_master) %>% stringr::str_subset(bool_pattern)
day_cat_cols  <- names(EMPRESS_feasibility_master) %>% stringr::str_subset(cat_pattern)

EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(
    across(all_of(day_bool_cols), to_logical),
    across(all_of(day_cat_cols),  to_cat)
  )
```

### 3.6 Data parsing

```{r}
# ----------------------------
# 1) Scan export for left-over python
# ----------------------------
# There are tring representation of a Python object that has leaked into data (often from a Python→R handoff, parquet import, or a column that contained mixed types)
py_obj_summary <- EMPRESS_feasibility_master %>%
  summarise(across(
    everything(),
    ~ sum(str_detect(as.character(.x), "<object "), na.rm = TRUE)
  )) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "n_py_object") %>%
  filter(n_py_object > 0) %>%
  arrange(desc(n_py_object))


EMPRESS_feasibility_master <- EMPRESS_feasibility_master %>%
  mutate(across(
    where(~ is.character(.x) || is.factor(.x)),
    ~ {
      x <- as.character(.x)
      x <- if_else(
        str_detect(x, "^<object object at 0x[0-9a-fA-F]+>$"),
        NA_character_,
        x
      )
      # Keep the original type if it was a factor; otherwise character
      if (is.factor(.x)) factor(x) else x
    }
  ))
```

## 4.0 Data validation

### 4.1 General datavalidation

#### 4.1.1 Structure and type

```{r}
variable_types <- EMPRESS_feasibility_master %>%
  as_tibble() %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  pivot_longer(
    cols = everything(),
    names_to = "variable",
    values_to = "type"
  )
```

#### 4.1.2 Day form logic

```{r}

```

### 4.2 Check for outliers

```{r}
# ----------------------------
# 1) Define validation rules
# ----------------------------
# Hard bounds = impossible/outside absolute physiological or data constraints
# Soft bounds = clinically implausible (flag for review), but possible
rules <- tibble::tribble(
  ~variable, ~hard_lo, ~hard_hi, ~soft_lo, ~soft_hi, ~unit,
  "weight",  20,  500,  22,  150, "kg",
  "height", 120,  240, 150,  200, "cm",
  "systolic_blood_pressure_lowest",  30,  300,  60,  240, "mmHg",
  "fio2_before_randomisation",        0,    1, 0.21,   1, "fraction",
  "max_oxygen_flow_at_randomisation", 0,  100,   0,  60, "L/min",
  "arterial_oxygen_saturation",       0,  100,  70, 100, "%",
  "peripheral_oxygen_saturation",     0,  100,  70, 100, "%",
  "pao2",                              0,   40,   4,  20, "kPa",
  "lactate_highest",                   0,   30, 0.5,  20, "mmol/L",
  "creatinine_highest",                0, 2000,  30, 1500, "µmol/L"
)

vars_to_validate <- c(
  "date_of_birth",
  "date_of_index_hospital_admission",
  "weight",
  "height",
  "systolic_blood_pressure_lowest",
  "fio2_before_randomisation",
  "max_oxygen_flow_at_randomisation",
  "arterial_oxygen_saturation",
  "pao2",
  "peripheral_oxygen_saturation",
  "lactate_highest",
  "creatinine_highest",
  "age_years"
)

# ----------------------------
# 2) Numeric hard/soft range issues (incl Age)
# ----------------------------
# Long format numeric values
num_long <- EMPRESS_feasibility_master %>%
  select(ssid, all_of(rules$variable), age_years) %>%
  pivot_longer(cols = -ssid, names_to = "variable", values_to = "value") %>%
  left_join(rules, by = "variable")

# Add Age hard/soft rules (18–110 hard; soft e.g. 18–95)
# (Hard > 110 flagged as hard; also < 18 hard)
age_rules <- tibble(
  variable = "age_years",
  hard_lo = 18, hard_hi = 110,
  soft_lo = 18, soft_hi = 95,
  unit = "years"
)

num_long <- num_long %>%
  rows_append(
    EMPRESS_feasibility_master %>%
      select(ssid, age_years) %>%
      rename(value = age_years) %>%
      mutate(variable = "age_years") %>%
      left_join(age_rules, by = "variable") %>%
      select(ssid, variable, value, hard_lo, hard_hi, soft_lo, soft_hi, unit)
  )

# Create a lookup table for responsible_site
responsible_site_lookup <- EMPRESS_events %>%
  mutate(ssid = as.character(ssid)) %>%
  select(ssid, enrolment_site) %>%
  filter(!is.na(enrolment_site)) %>%
  distinct(ssid, .keep_all = TRUE)

validation_numeric <- num_long %>%
  filter(!is.na(value)) %>%
  mutate(
    # force numeric comparisons (avoid character weirdness)
    value_num = suppressWarnings(as.numeric(value))
  ) %>%
  filter(!is.na(value_num)) %>%
  mutate(
    issue_type = case_when(
      value_num < hard_lo | value_num > hard_hi ~ "hard",
      value_num < soft_lo | value_num > soft_hi ~ "soft",
      TRUE ~ NA_character_
    ),
    note = case_when(
      issue_type == "hard" ~ paste0("Outside hard bounds [", hard_lo, ", ", hard_hi, "] ", unit),
      issue_type == "soft" ~ paste0("Outside soft bounds [", soft_lo, ", ", soft_hi, "] ", unit),
      TRUE ~ NA_character_
    ),
    value = as.character(value_num)
  ) %>%
  filter(!is.na(issue_type)) %>%
  left_join(responsible_site_lookup, by = "ssid") %>%
  relocate(enrolment_site, .after = ssid) %>%
  select(-value_num, -hard_lo, -soft_lo, -soft_hi, -hard_hi)

# ----------------------------
# 3) Numeric issues by IQR and z-score
# ----------------------------
num_outliers <- EMPRESS_feasibility_master %>%
  select(ssid, where(is.numeric)) %>%
  pivot_longer(-ssid, names_to = "variable", values_to = "value") %>%
  group_by(variable) %>%
  mutate(
    q1 = quantile(value, 0.25, na.rm = TRUE),
    q3 = quantile(value, 0.75, na.rm = TRUE),
    iqr = q3 - q1,
    lo = q1 - 1.5 * iqr,
    hi = q3 + 1.5 * iqr,
    is_outlier = !is.na(value) & (value < lo | value > hi)
  ) %>%
  ungroup() %>%
  filter(is_outlier) %>%
  left_join(responsible_site_lookup, by = "ssid") %>%
  relocate(enrolment_site, .after = ssid) %>%
  select(ssid, enrolment_site, variable, value, lo, hi)
```

### 4.3 Potential date issues

```{r}
validation_dates <- EMPRESS_feasibility_master %>%
  transmute(
    ssid = as.character(ssid),
    dob  = date_of_birth,
    adm  = date_of_index_hospital_admission,
    rand = rand_time,
    tod  = tod,
    age  = age_years
  ) %>%
  # Create multiple issue rows per ssid (one row per triggered rule)
  mutate(issues = pmap(list(dob, adm, rand, tod, age), function(dob, adm, rand, tod, age) {

    out <- tibble(variable = character(), issue_type = character(), value = character(), note = character())

    # ----------------------------
    # HARD: impossible / clearly wrong
    # ----------------------------

    # DOB in the future
    if (!is.na(dob) && dob > Sys.Date()) {
      out <- bind_rows(out, tibble(
        variable = "date_of_birth",
        issue_type = "hard",
        value = as.character(dob),
        note = "Date of birth is in the future"
      ))
    }

    # DOB after randomisation date
    if (!is.na(dob) && !is.na(rand) && dob > as.Date(rand)) {
      out <- bind_rows(out, tibble(
        variable = "date_of_birth",
        issue_type = "hard",
        value = as.character(dob),
        note = paste0("Date of birth (", dob, ") is after randomisation date (", as.Date(rand), ")")
      ))
    }

    # Admission before DOB
    if (!is.na(adm) && !is.na(dob) && adm < dob) {
      out <- bind_rows(out, tibble(
        variable = "date_of_index_hospital_admission",
        issue_type = "hard",
        value = as.character(adm),
        note = paste0("Admission date (", adm, ") is before date of birth (", dob, ")")
      ))
    }

    # Randomisation before admission 
    if (!is.na(rand) && !is.na(adm) && as.Date(rand) < adm) {
      out <- bind_rows(out, tibble(
        variable = "rand_time",
        issue_type = "hard",
        value = as.character(rand),
        note = paste0("Randomisation date (", as.Date(rand), ") is before admission date (", adm, ")")
      ))
    }

    # Time of death before randomisation 
    if (!is.na(tod) && !is.na(rand) && tod < rand) {
      out <- bind_rows(out, tibble(
        variable = "tod",
        issue_type = "hard",
        value = as.character(tod),
        note = paste0("Time of death (", tod, ") is before randomisation time (", rand, ")")
      ))
    }

    # ----------------------------
    # SOFT: suspicious / needs review
    # ----------------------------

    # Randomisation timestamp far in the future 
    if (!is.na(rand) && rand > (Sys.time() + days(1))) {
      out <- bind_rows(out, tibble(
        variable = "rand_time",
        issue_type = "soft",
        value = as.character(rand),
        note = "Randomisation time is in the future (> 1 day from now)"
      ))
    }

    # Admission extremely far in past (example: > 20 years ago) 
    if (!is.na(adm) && adm < (Sys.Date() - years(20))) {
      out <- bind_rows(out, tibble(
        variable = "date_of_index_hospital_admission",
        issue_type = "soft",
        value = as.character(adm),
        note = "Admission date is > 20 years in the past (check year parsing)"
      ))
    }

    # Death long after randomisation 
    # Adjust threshold (e.g., > 365 days) to match your context
    if (!is.na(tod) && !is.na(rand) && tod > (rand + days(365))) {
      out <- bind_rows(out, tibble(
        variable = "tod",
        issue_type = "soft",
        value = as.character(tod),
        note = "Time of death is > 365 days after randomisation (check linkage/timestamp)"
      ))
    }

    # Missingness checks (often useful in date QC)
    # Example: rand present but admission missing
    if (!is.na(rand) && is.na(adm)) {
      out <- bind_rows(out, tibble(
        variable = "date_of_index_hospital_admission",
        issue_type = "soft",
        value = NA_character_,
        note = "Admission date missing but randomisation time present"
      ))
    }

    out
  })) %>%
  select(ssid, issues) %>%
  tidyr::unnest(issues)
```

### 4.4 Missing data

```{r}
# Helper: normalize yes/no strings
yn <- function(x) stringr::str_to_lower(stringr::str_squish(as.character(x)))

# Responsible site lookup (safe)
responsible_site_lookup <- EMPRESS_feasibility_master %>%
  transmute(ssid = as.character(ssid), enrolment_site) %>%
  distinct(ssid, .keep_all = TRUE)

validation_missing_all <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  mutate(across(everything(), as.character)) %>%
  pivot_longer(
    cols = -ssid,
    names_to = "variable",
    values_to = "value"
  ) %>%
  mutate(
    value_clean = stringr::str_squish(value),
    is_missing  = is.na(value) | value_clean == ""
  ) %>%
  filter(is_missing) %>%
  select(ssid, variable) %>%
  left_join(responsible_site_lookup, by = "ssid") %>%
  transmute(
    ssid,
    enrolment_site,
    variable,
    issue_type = "missing",
    value = NA_character_
  )

expected_missing_baseline <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  mutate(across(everything(), as.character)) %>%
  rowwise() %>%
  mutate(
    expected_vars = list(unique(unlist(c(

      if (!is.na(yn(positive_bacterial_culture)) &&
          yn(positive_bacterial_culture) == "no")
        c("type_of_sample",
          "type_of_bacteria",
          "resistance_to_piperacillin_tazobactam",
          "resistance_to_meropenem"),

      if (!is.na(yn(use_of_respiratory_support_at_randomisation)) &&
          yn(use_of_respiratory_support_at_randomisation) == "no")
        c("type_of_respiratory_support",
          "max_oxygen_flow_at_randomisation",
          "fio2_before_randomisation"),

      if (!is.na(yn(use_of_respiratory_support_at_randomisation)) &&
          yn(use_of_respiratory_support_at_randomisation) == "yes" &&
          !(stringr::str_squish(type_of_respiratory_support) ==
              "supplementary_oxygen_flow_ge_10_l_min"))
        c("max_oxygen_flow_at_randomisation"),

      if (!is.na(yn(use_of_respiratory_support_at_randomisation)) &&
          yn(use_of_respiratory_support_at_randomisation) == "yes" &&
          !(stringr::str_squish(type_of_respiratory_support) %in% c(
            "invasive_mechanical_ventilation",
            "noninvasive_ventilation",
            "continuous_use_of_cpap"
          )))
        c("fio2_before_randomisation"),

      if (!is.na(yn(treatment_with_antibacterial_agent_prior_to_randomisation)) &&
          yn(treatment_with_antibacterial_agent_prior_to_randomisation) == "no")
        c("anti_bacterial_agent"),

      if (!is.na(yn(arterial_blood_gas_available)) &&
          yn(arterial_blood_gas_available) == "no")
        c("arterial_oxygen_saturation", "pao2"),

      if (!is.na(yn(arterial_blood_gas_available)) &&
          yn(arterial_blood_gas_available) == "yes")
        c("peripheral_oxygen_saturation")

    ))))
  ) %>%
  ungroup() %>%
  tidyr::unnest_longer(expected_vars, values_to = "variable") %>%
  filter(!is.na(variable), variable != "") %>%
  select(ssid, variable) %>%
  distinct()

# Parse dayform columns to (ssid, day, var, value)
dayform_long <- EMPRESS_feasibility_master %>%
  mutate(ssid = as.character(ssid)) %>%
  mutate(across(everything(), as.character)) %>%
  select(ssid, matches("^dayform_\\d+__")) %>%
  pivot_longer(
    cols = -ssid,
    names_to = "col",
    values_to = "value"
  ) %>%
  mutate(
    day = as.integer(stringr::str_extract(col, "(?<=^dayform_)\\d+")),  # <-- FIXED
    var = stringr::str_replace(col, "^dayform_\\d+__", ""),
    value = stringr::str_squish(value),
    value = dplyr::na_if(value, "")
  )

# Parent values per ssid+day
dayform_parents_wide <- dayform_long %>%
  filter(var %in% c(
    "isolation_due_to_resistant_bacteria",
    "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
    "use_of_any_another_antibiotic_agent_than_allocated_on_this_day"
  )) %>%
  select(ssid, day, var, value) %>%
  tidyr::pivot_wider(
    names_from = var,
    values_from = value,
    values_fn = ~ dplyr::first(na.omit(.x)),   # safety: enforce scalar
    values_fill = NA_character_
  )

# Expected missing child variables -> build EXPECTED COLUMN NAMES that MATCH REAL DATA
expected_missing_dayform <- dayform_parents_wide %>%
  rowwise() %>%
  mutate(
    expected_child_vars = list(unique(unlist(c(

      # Isolation: if NO => children not applicable (expected missing)
      if (!is.na(yn(isolation_due_to_resistant_bacteria)) &&
          yn(isolation_due_to_resistant_bacteria) == "no")
        c("type_of_resistant_bacteria_new",
          "antibiotic_agent_to_which_the_bacteria_was_resistant"),

      # Dose >=50%: if YES => reason not applicable
      if (!is.na(yn(did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose)) &&
          yn(did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose) == "yes")
        c("reason_for_not_receiving_at_least_50_percent"),

      # Other antibiotics: if NO => children not applicable
      if (!is.na(yn(use_of_any_another_antibiotic_agent_than_allocated_on_this_day)) &&
          yn(use_of_any_another_antibiotic_agent_than_allocated_on_this_day) == "no")
        c("other_antibiotic_agent_than_allocated_type_treatment",
          "other_antibiotic_agent_than_allocated_type_agent")

    ))))
  ) %>%
  ungroup() %>%
  tidyr::unnest_longer(expected_child_vars, values_to = "child_var") %>%
  filter(!is.na(child_var), child_var != "") %>%
  mutate(
    variable = paste0("dayform_", day, "__", child_var)   # <-- FIXED: double underscore
  ) %>%
  select(ssid, variable) %>%
  distinct()

expected_missing_all <- bind_rows(
  expected_missing_baseline %>% mutate(variable = as.character(variable)),
  expected_missing_dayform  %>% mutate(variable = as.character(variable))
) %>%
  filter(!is.na(variable), variable != "") %>%
  distinct(ssid, variable)

validation_missing_unexpected <- validation_missing_all %>%
  anti_join(expected_missing_all, by = c("ssid", "variable"))
```

## 5.0 Data analysis

### 5.1 Table 1: Feasibility outcomes

#### 5.1.1 Creation of subset for 5.1.2, 5.1.3, 5.1.4 and 5.1.5

```{r}
EMPRESS_feasibility_table <- EMPRESS_events_test %>% 
  filter(
    str_detect(event_type_name, "enrolment|exclusion") |
      str_detect(event_type_name, "withdrawn_consent") |
      str_detect(event_type_name, "Death")
  )
```

#### 5.1.2 Creation of a subset for 5.1.7

```{r}
EMPRESS_feasibility_table_protocol_adherence <- EMPRESS_forms_test %>%
  filter(
    str_detect(variable_name, "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose") |
      str_detect(variable_name, "reason_for_not_receiving_at_least_50_percent")
  )
```

#### 5.1.3 Feasibility outcome 1: Time to completion of the feasibility phase

```{r}
# standardise  is POSIXct (adapt format if needed)
EMPRESS_feasibility_table <- EMPRESS_feasibility_table %>% 
  mutate(timestamp = ymd_hms(timestamp))  # or dmy_hms(), etc.

# Calculate time in whole months between enrolment #1 to #200
enrolment_1_to_200 <- EMPRESS_feasibility_table %>% 
  filter(str_detect(event_type_name, "enrolment")) %>%   # only enrolments
  arrange(timestamp) %>%                                  # order chronologically
  summarise(
    `Enrolment of #1`  = first(timestamp),
    `Enrolment of #200`  = nth(timestamp, 200),              # 200th enrolment
    `Months from #1 to #200`    = round(
      time_length(interval(`Enrolment of #1`, `Enrolment of #200`), "month")
    )
  )

enrolment_1_to_200
```

#### 5.1.4 Feasibility outcome 2: Recruitment proportion

```{r}
enrol_excl_summary <- EMPRESS_feasibility_table %>% 
  # keep only enrolment and exclusion rows
  filter(str_detect(event_type_name, "enrolment|exclusion")) %>% 
  mutate(
    status = case_when(
      str_detect(event_type_name, "enrolment") ~ "Randomised",
      str_detect(event_type_name, "exclusion") ~ "Excluded"
    )
  ) %>% 
  # count distinct participants in each group
  distinct(ssid, status) %>% 
  count(status, name = "n") %>% 
  # reshape into wide format
  tidyr::pivot_wider(
    names_from = status,
    values_from = n,
    values_fill = 0
  ) %>% 
  # calculate totals and proportions
  mutate(
    Total = Randomised + Excluded,
    `Recruitment proportion` = round((Randomised / Total) * 100, 1),
  )

enrol_excl_summary
```

#### 5.1.5 Feasibility outcome 3: Proportion without consent to use data

```{r}
consent_summary <- EMPRESS_feasibility_table %>% 
  # Identify enrolments
  mutate(is_enrolment = str_detect(event_type_name, "enrolment")) %>% 
  summarise(
    `No to use of data` = n_distinct(ssid[data_collection_allowed == "no"]),
    Enrolled   = n_distinct(ssid[is_enrolment]),
    `Proportion without consent to use data` = `No to use of data` / Enrolled
  )

consent_summary
```

#### 5.1.6 Feasibility outcome 4: Retention proportion

```{r}
# Afvent at der bliver tilføjet en ekstra variabel med henblik på at kunne se hvornår data er tastet
```

#### 5.1.7 Feasibility outcome 5: Protocol adherence

```{r}
# Count participants with ≥1 protocol violation
participants_with_violation <- EMPRESS_feasibility_table_protocol_adherence %>% 
  filter(value %in% c("By error", "Other reason(s)")) %>% 
  distinct(ssid) %>% 
  summarise(`≥1 protocol violation` = n())

# Total number of randomised participants (given as 235)
total_randomised <- 235 # must be changed accordingly when running script

# Calculate number without protocol violations + proportion
protocol_clean_summary <- participants_with_violation %>% 
  mutate(
    `No violation among enrolled` = total_randomised - `≥1 protocol violation`,
    `Protocol adherence` = `No violation among enrolled` / total_randomised
  )

protocol_clean_summary
```

#### 5.1.7.1 Calculation of protocol violations

```{r}
participants_with_violation <- EMPRESS_forms_test %>% 
  filter(
    # Original criteria
    value %in% c("By error", "Other reason(s)") |
    
    # use_of_any_another_antibiotic_agent_than_allocated_on_this_day = Yes
    (variable_name == "use_of_any_another_antibiotic_agent_than_allocated_on_this_day" &
       value == "Yes") |
    
    # other_antibiotic_agent_than_allocated_type_treatment = Empirical treatment
    (variable_name == "other_antibiotic_agent_than_allocated_type_treatment" &
       value == "Empirical treatment") |
    
    # other_antibiotic_agent_than_allocated_type_agent = any value (non-missing, non-empty)
    (variable_name == "other_antibiotic_agent_than_allocated_type_agent" &
       !is.na(value) & value != "")
  )

# DENNE SEKTION SKAL ERSTATTES MED REEL ALLOKERING
# violations_with_blinded_arm <- participants_with_violation %>% 
#   left_join(
#     EMPRESS_allocation %>% select(ssid, allocated_arm),
#     by = "ssid"
#   )

participants_with_violation <- 
```
